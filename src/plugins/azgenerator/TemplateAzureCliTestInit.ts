/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { CodeModelAz } from "./CodeModelAz"

export function GenerateAzureCliTestInit(model: CodeModelAz) : string[] {
    var output: string[] = [];

    output.push("# coding=utf-8");
    output.push("# --------------------------------------------------------------------------");
    output.push("# Copyright (c) Microsoft Corporation. All rights reserved.");
    output.push("# Licensed under the MIT License. See License.txt in the project root for");
    output.push("# license information.");
    output.push("#");
    output.push("# Code generated by Microsoft (R) AutoRest Code Generator.");
    output.push("# Changes may cause incorrect behavior and will be lost if the code is");
    output.push("# regenerated.");
    output.push("# --------------------------------------------------------------------------");
    output.push("import inspect");
    output.push("import os");
    output.push("");
    output.push("");
    output.push("__path__ = __import__('pkgutil').extend_path(__path__, __name__)");
    output.push('');
    output.push('');
    output.push('def try_manual(func):');
    output.push('    def import_manual_function(origin_func):');
    output.push('        from importlib import import_module');
    output.push('        decorated_path = inspect.getfile(origin_func)');
    output.push('        module_path = __path__[0]');
    output.push('        if not decorated_path.startswith(module_path):');
    output.push('            raise Exception("Decorator can only be used in submodules!")');
    output.push('        manual_path = os.path.join(');
    output.push('            decorated_path[module_path.rfind(os.path.sep) + 1:])');
    output.push('        manual_file_path, manual_file_name = os.path.split(manual_path)');
    output.push('        module_name, _ = os.path.splitext(manual_file_name)');
    output.push('        manual_module = "..manual." + \\');
    output.push('            ".".join(manual_file_path.split(os.path.sep) + [module_name, ])');
    output.push('        return getattr(import_module(manual_module, package=__name__), origin_func.__name__)');
    output.push('');
    output.push('    def get_func_to_call():');
    output.push('        func_to_call = func');
    output.push('        try:');
    output.push('            func_to_call = import_manual_function(func)');
    output.push('        except (ImportError, AttributeError):');
    output.push('            pass');
    output.push('        return func_to_call');
    output.push('');
    output.push('    def wrapper(*args, **kwargs):');
    output.push('        func_to_call = get_func_to_call()');
    output.push('        print("running {}()...".format(func.__name__))');
    output.push('        return func_to_call(*args, **kwargs)');
    output.push('');
    output.push('    if inspect.isclass(func):');
    output.push('        return get_func_to_call()');
    output.push('    else:');
    output.push('        return wrapper');
    output.push('');
    return output;
}
