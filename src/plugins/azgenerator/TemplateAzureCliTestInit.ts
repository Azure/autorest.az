/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { CodeModelAz } from "./CodeModelAz"

export function GenerateAzureCliTestInit(model: CodeModelAz): string[] {
    var output: string[] = [];

    output.push("# coding=utf-8");
    output.push("# --------------------------------------------------------------------------");
    output.push("# Copyright (c) Microsoft Corporation. All rights reserved.");
    output.push("# Licensed under the MIT License. See License.txt in the project root for");
    output.push("# license information.");
    output.push("#");
    output.push("# Code generated by Microsoft (R) AutoRest Code Generator.");
    output.push("# Changes may cause incorrect behavior and will be lost if the code is");
    output.push("# regenerated.");
    output.push("# --------------------------------------------------------------------------");
    output.push("import inspect");
    output.push("import os");
    output.push("import sys");
    output.push("import traceback");
    output.push("from azure.core.exceptions import AzureError");
    output.push("from azure.cli.testsdk.exceptions import CliTestError, CliExecutionError, JMESPathCheckAssertionError");
    output.push("");
    output.push("");
    output.push("__path__ = __import__('pkgutil').extend_path(__path__, __name__)");
    output.push("exceptions = []");
    output.push('');
    output.push('');
    output.push('def try_manual(func):');
    output.push('    def import_manual_function(origin_func):');
    output.push('        from importlib import import_module');
    output.push('        decorated_path = inspect.getfile(origin_func)');
    output.push('        module_path = __path__[0]');
    output.push('        if not decorated_path.startswith(module_path):');
    output.push('            raise Exception("Decorator can only be used in submodules!")');
    output.push('        manual_path = os.path.join(');
    output.push('            decorated_path[module_path.rfind(os.path.sep) + 1:])');
    output.push('        manual_file_path, manual_file_name = os.path.split(manual_path)');
    output.push('        module_name, _ = os.path.splitext(manual_file_name)');
    output.push('        manual_module = "..manual." + \\');
    output.push('            ".".join(manual_file_path.split(os.path.sep) + [module_name, ])');
    output.push('        return getattr(import_module(manual_module, package=__name__), origin_func.__name__)');
    output.push('');
    output.push('    def get_func_to_call():');
    output.push('        func_to_call = func');
    output.push('        try:');
    output.push('            func_to_call = import_manual_function(func)');
    output.push('            print("Found manual override for {}(...)".format(func.__name__))')
    output.push('        except (ImportError, AttributeError):');
    output.push('            pass');
    output.push('        return func_to_call');
    output.push('');
    output.push('    def wrapper(*args, **kwargs):');
    output.push('        func_to_call = get_func_to_call()');
    output.push('        print("running {}()...".format(func.__name__))');
    output.push('        try:');
    output.push('            return func_to_call(*args, **kwargs)');
    output.push('        except (AssertionError, AzureError, CliTestError, CliExecutionError, JMESPathCheckAssertionError) as e:');
    output.push('            print("--------------------------------------")');
    output.push('            print("step exception: ", e)');
    output.push('            print("--------------------------------------", file=sys.stderr)');
    output.push('            print("step exception in {}: {}".format(func.__name__, e), file=sys.stderr)');
    output.push('            traceback.print_exc()');
    output.push('            exceptions.append((func.__name__, sys.exc_info()))');
    output.push('');
    output.push('    if inspect.isclass(func):');
    output.push('        return get_func_to_call()');
    output.push('    return wrapper');
    output.push('');
    output.push('');
    output.push('def raise_if():');
    output.push('    if exceptions:');
    output.push('        if len(exceptions) <= 1:');
    output.push('            raise exceptions[0][1][1]');
    output.push('        message = "{}\\nFollowed with exceptions in other steps:\\n".format(str(exceptions[0][1][1]))');
    output.push('        message += "\\n".join(["{}: {}".format(h[0], h[1][1]) for h in exceptions[1:]])');
    output.push('        raise exceptions[0][1][0](message).with_traceback(exceptions[0][1][2])');
    output.push('');

    return output;
}
