# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

import msrest.serialization


class AccessPolicyResponse(msrest.serialization.Model):
    """Get Data Plane read only token response definition.

    :param policy: The user access policy.
    :type policy: ~dfaz_management_client.models.UserAccessPolicy
    :param access_token: Data Plane read only access token.
    :type access_token: str
    :param data_plane_url: Data Plane service base URL.
    :type data_plane_url: str
    """

    _attribute_map = {
        'policy': {'key': 'policy', 'type': 'UserAccessPolicy'},
        'access_token': {'key': 'accessToken', 'type': 'str'},
        'data_plane_url': {'key': 'dataPlaneUrl', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(AccessPolicyResponse, self).__init__(**kwargs)
        self.policy = kwargs.get('policy', None)
        self.access_token = kwargs.get('access_token', None)
        self.data_plane_url = kwargs.get('data_plane_url', None)


class JobBase(msrest.serialization.Model):
    """Job base definition.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ComputeJobBase.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param job_type: Required. Specifies the type of job.Constant filled by server.  Possible
     values include: "Command", "Sweep", "Labeling", "Pipeline", "Data", "AutoML".
    :type job_type: str or ~dfaz_management_client.models.JobType
    :ivar interaction_endpoints: Dictonary of endpoint URIs, keyed by enumerated JobEndpoints, can
     be added, removed or updated.
    :vartype interaction_endpoints: ~dfaz_management_client.models.JobBaseInteractionEndpoints
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    """

    _validation = {
        'job_type': {'required': True},
        'interaction_endpoints': {'readonly': True},
    }

    _attribute_map = {
        'job_type': {'key': 'jobType', 'type': 'str'},
        'interaction_endpoints': {'key': 'interactionEndpoints', 'type': 'JobBaseInteractionEndpoints'},
        'description': {'key': 'description', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    _subtype_map = {
        'job_type': {'ComputeJobBase': 'ComputeJobBase'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(JobBase, self).__init__(**kwargs)
        self.job_type = None  # type: Optional[str]
        self.interaction_endpoints = None
        self.description = kwargs.get('description', None)
        self.tags = kwargs.get('tags', None)


class ComputeJobBase(JobBase):
    """Compute job base definition.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: CommandJob.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param job_type: Required. Specifies the type of job.Constant filled by server.  Possible
     values include: "Command", "Sweep", "Labeling", "Pipeline", "Data", "AutoML".
    :type job_type: str or ~dfaz_management_client.models.JobType
    :ivar interaction_endpoints: Dictonary of endpoint URIs, keyed by enumerated JobEndpoints, can
     be added, removed or updated.
    :vartype interaction_endpoints: ~dfaz_management_client.models.JobBaseInteractionEndpoints
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param experiment_name: The name of the experiment the job belongs to. If not set, the job is
     placed in the "Default" experiment.
    :type experiment_name: str
    :param compute_binding: Required. computeBinding of the job.
    :type compute_binding: str
    """

    _validation = {
        'job_type': {'required': True},
        'interaction_endpoints': {'readonly': True},
        'compute_binding': {'required': True},
    }

    _attribute_map = {
        'job_type': {'key': 'jobType', 'type': 'str'},
        'interaction_endpoints': {'key': 'interactionEndpoints', 'type': 'JobBaseInteractionEndpoints'},
        'description': {'key': 'description', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'experiment_name': {'key': 'experimentName', 'type': 'str'},
        'compute_binding': {'key': 'computeBinding', 'type': 'str'},
    }

    _subtype_map = {
        'job_type': {'CommandJob': 'CommandJob'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ComputeJobBase, self).__init__(**kwargs)
        self.job_type = 'ComputeJobBase'  # type: str
        self.experiment_name = kwargs.get('experiment_name', None)
        self.compute_binding = kwargs['compute_binding']


class CommandJob(ComputeJobBase):
    """Code Job definition.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AutomlJob.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param job_type: Required. Specifies the type of job.Constant filled by server.  Possible
     values include: "Command", "Sweep", "Labeling", "Pipeline", "Data", "AutoML".
    :type job_type: str or ~dfaz_management_client.models.JobType
    :ivar interaction_endpoints: Dictonary of endpoint URIs, keyed by enumerated JobEndpoints, can
     be added, removed or updated.
    :vartype interaction_endpoints: ~dfaz_management_client.models.JobBaseInteractionEndpoints
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param experiment_name: The name of the experiment the job belongs to. If not set, the job is
     placed in the "Default" experiment.
    :type experiment_name: str
    :param compute_binding: Required. computeBinding of the job.
    :type compute_binding: str
    :param status: Status of the job. Possible values include: "NotStarted", "Starting",
     "Provisioning", "Preparing", "Queued", "Running", "Finalizing", "CancelRequested", "Completed",
     "Failed", "Canceled", "NotResponding", "Paused".
    :type status: str or ~dfaz_management_client.models.JobStatus
    :param max_run_duration_seconds: The max run duration in seconds, ater which the job will be
     cancelled.
    :type max_run_duration_seconds: long
    :param code_configuration: Required. Code Configuration of the job.
    :type code_configuration: str
    :param environment_id: Environment specification of the job.
    :type environment_id: str
    :param data_bindings: Mapping of data bindings used in the job.
    :type data_bindings: object
    :param distribution_configuration: Distributon configuration of the job. This should be one of
     MpiConfiguration, TensorflowConfiguration, or PyTorchConfiguration.
    :type distribution_configuration: object
    """

    _validation = {
        'job_type': {'required': True},
        'interaction_endpoints': {'readonly': True},
        'compute_binding': {'required': True},
        'code_configuration': {'required': True},
    }

    _attribute_map = {
        'job_type': {'key': 'jobType', 'type': 'str'},
        'interaction_endpoints': {'key': 'interactionEndpoints', 'type': 'JobBaseInteractionEndpoints'},
        'description': {'key': 'description', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'experiment_name': {'key': 'experimentName', 'type': 'str'},
        'compute_binding': {'key': 'computeBinding', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'max_run_duration_seconds': {'key': 'maxRunDurationSeconds', 'type': 'long'},
        'code_configuration': {'key': 'codeConfiguration', 'type': 'str'},
        'environment_id': {'key': 'environmentId', 'type': 'str'},
        'data_bindings': {'key': 'dataBindings', 'type': 'object'},
        'distribution_configuration': {'key': 'distributionConfiguration', 'type': 'object'},
    }

    _subtype_map = {
        'job_type': {'AutoML': 'AutomlJob'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(CommandJob, self).__init__(**kwargs)
        self.job_type = 'CommandJob'  # type: str
        self.status = kwargs.get('status', None)
        self.max_run_duration_seconds = kwargs.get('max_run_duration_seconds', None)
        self.code_configuration = kwargs['code_configuration']
        self.environment_id = kwargs.get('environment_id', None)
        self.data_bindings = kwargs.get('data_bindings', None)
        self.distribution_configuration = kwargs.get('distribution_configuration', None)


class AutomlJob(CommandJob):
    """Automl Job definition.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: TestJob.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param job_type: Required. Specifies the type of job.Constant filled by server.  Possible
     values include: "Command", "Sweep", "Labeling", "Pipeline", "Data", "AutoML".
    :type job_type: str or ~dfaz_management_client.models.JobType
    :ivar interaction_endpoints: Dictonary of endpoint URIs, keyed by enumerated JobEndpoints, can
     be added, removed or updated.
    :vartype interaction_endpoints: ~dfaz_management_client.models.JobBaseInteractionEndpoints
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param experiment_name: The name of the experiment the job belongs to. If not set, the job is
     placed in the "Default" experiment.
    :type experiment_name: str
    :param compute_binding: Required. computeBinding of the job.
    :type compute_binding: str
    :param status: Status of the job. Possible values include: "NotStarted", "Starting",
     "Provisioning", "Preparing", "Queued", "Running", "Finalizing", "CancelRequested", "Completed",
     "Failed", "Canceled", "NotResponding", "Paused".
    :type status: str or ~dfaz_management_client.models.JobStatus
    :param max_run_duration_seconds: The max run duration in seconds, ater which the job will be
     cancelled.
    :type max_run_duration_seconds: long
    :param code_configuration: Required. Code Configuration of the job.
    :type code_configuration: str
    :param environment_id: Environment specification of the job.
    :type environment_id: str
    :param data_bindings: Mapping of data bindings used in the job.
    :type data_bindings: object
    :param distribution_configuration: Distributon configuration of the job. This should be one of
     MpiConfiguration, TensorflowConfiguration, or PyTorchConfiguration.
    :type distribution_configuration: object
    :param run_type: Run type.
    :type run_type: str
    :param run_source: Run source would be used by services calling AutoML CreateParentRun,
     if none is provided it would default to "AutoML"
     This value would be used for RootAttribution.
    :type run_source: str
    :param num_iterations: Number of iterations.
    :type num_iterations: int
    :param training_type: Training type. Possible values include: "TrainFull", "TrainAndValidate",
     "CrossValidate", "MeanCrossValidate".
    :type training_type: str or ~dfaz_management_client.models.TrainingType
    :param acquisition_function: Aquisition function. Possible values include: "EI", "PI", "UCB".
    :type acquisition_function: str or ~dfaz_management_client.models.AcquisitionFunction
    :param metrics: Optimization metrics.
    :type metrics: list[str or ~dfaz_management_client.models.OptimizationMetric]
    :param primary_metric: Primary optimization metric. Possible values include: "AUC_weighted",
     "Accuracy", "Norm_macro_recall", "Average_precision_score_weighted",
     "Precision_score_weighted", "Spearman_correlation", "Normalized_root_mean_squared_error",
     "R2_score", "Normalized_mean_absolute_error", "Normalized_root_mean_squared_log_error",
     "Mean_average_precision", "Iou".
    :type primary_metric: str or ~dfaz_management_client.models.OptimizationMetric
    :param train_split: Train split percentage.
    :type train_split: float
    :param acquisition_parameter: Aquisition parameter.
    :type acquisition_parameter: float
    :param num_cross_validation: Num cross validation.
    :type num_cross_validation: int
    :param target: Target.
    :type target: str
    :param aml_settings_json_string: AMLSettings Json string.
    :type aml_settings_json_string: str
    :param data_prep_json_string: Serialized DataPrep dataflow object.
    :type data_prep_json_string: str
    :param enable_subsampling: Enable subsampling.
    :type enable_subsampling: bool
    :param scenario: Which scenario is being used to mapping to a curated environment.
    :type scenario: str
    :param parent_run_id: The parent run id for the current parent run dto.
    :type parent_run_id: str
    """

    _validation = {
        'job_type': {'required': True},
        'interaction_endpoints': {'readonly': True},
        'compute_binding': {'required': True},
        'code_configuration': {'required': True},
    }

    _attribute_map = {
        'job_type': {'key': 'jobType', 'type': 'str'},
        'interaction_endpoints': {'key': 'interactionEndpoints', 'type': 'JobBaseInteractionEndpoints'},
        'description': {'key': 'description', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'experiment_name': {'key': 'experimentName', 'type': 'str'},
        'compute_binding': {'key': 'computeBinding', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'max_run_duration_seconds': {'key': 'maxRunDurationSeconds', 'type': 'long'},
        'code_configuration': {'key': 'codeConfiguration', 'type': 'str'},
        'environment_id': {'key': 'environmentId', 'type': 'str'},
        'data_bindings': {'key': 'dataBindings', 'type': 'object'},
        'distribution_configuration': {'key': 'distributionConfiguration', 'type': 'object'},
        'run_type': {'key': 'runType', 'type': 'str'},
        'run_source': {'key': 'runSource', 'type': 'str'},
        'num_iterations': {'key': 'numIterations', 'type': 'int'},
        'training_type': {'key': 'trainingType', 'type': 'str'},
        'acquisition_function': {'key': 'acquisitionFunction', 'type': 'str'},
        'metrics': {'key': 'metrics', 'type': '[str]'},
        'primary_metric': {'key': 'primaryMetric', 'type': 'str'},
        'train_split': {'key': 'trainSplit', 'type': 'float'},
        'acquisition_parameter': {'key': 'acquisitionParameter', 'type': 'float'},
        'num_cross_validation': {'key': 'numCrossValidation', 'type': 'int'},
        'target': {'key': 'target', 'type': 'str'},
        'aml_settings_json_string': {'key': 'amlSettingsJsonString', 'type': 'str'},
        'data_prep_json_string': {'key': 'dataPrepJsonString', 'type': 'str'},
        'enable_subsampling': {'key': 'enableSubsampling', 'type': 'bool'},
        'scenario': {'key': 'scenario', 'type': 'str'},
        'parent_run_id': {'key': 'parentRunId', 'type': 'str'},
    }

    _subtype_map = {
        'job_type': {'TestJob': 'TestJob'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(AutomlJob, self).__init__(**kwargs)
        self.job_type = 'AutoML'  # type: str
        self.run_type = kwargs.get('run_type', None)
        self.run_source = kwargs.get('run_source', None)
        self.num_iterations = kwargs.get('num_iterations', None)
        self.training_type = kwargs.get('training_type', None)
        self.acquisition_function = kwargs.get('acquisition_function', None)
        self.metrics = kwargs.get('metrics', None)
        self.primary_metric = kwargs.get('primary_metric', None)
        self.train_split = kwargs.get('train_split', None)
        self.acquisition_parameter = kwargs.get('acquisition_parameter', None)
        self.num_cross_validation = kwargs.get('num_cross_validation', None)
        self.target = kwargs.get('target', None)
        self.aml_settings_json_string = kwargs.get('aml_settings_json_string', None)
        self.data_prep_json_string = kwargs.get('data_prep_json_string', None)
        self.enable_subsampling = kwargs.get('enable_subsampling', None)
        self.scenario = kwargs.get('scenario', None)
        self.parent_run_id = kwargs.get('parent_run_id', None)


class Trigger(msrest.serialization.Model):
    """Azure data factory nested object which contains information about creating pipeline run.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ChainingTrigger, MultiplePipelineTrigger, RerunTumblingWindowTrigger, TumblingWindowTrigger.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param type: Required. Trigger type.Constant filled by server.
    :type type: str
    :param description: Trigger description.
    :type description: str
    :ivar runtime_state: Indicates if trigger is running or not. Updated when Start/Stop APIs are
     called on the Trigger. Possible values include: "Started", "Stopped", "Disabled".
    :vartype runtime_state: str or ~dfaz_management_client.models.TriggerRuntimeState
    :param annotations: List of tags that can be used for describing the trigger.
    :type annotations: list[object]
    """

    _validation = {
        'type': {'required': True},
        'runtime_state': {'readonly': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'type': {'key': 'type', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'runtime_state': {'key': 'runtimeState', 'type': 'str'},
        'annotations': {'key': 'annotations', 'type': '[object]'},
    }

    _subtype_map = {
        'type': {'ChainingTrigger': 'ChainingTrigger', 'MultiplePipelineTrigger': 'MultiplePipelineTrigger', 'RerunTumblingWindowTrigger': 'RerunTumblingWindowTrigger', 'TumblingWindowTrigger': 'TumblingWindowTrigger'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(Trigger, self).__init__(**kwargs)
        self.additional_properties = kwargs.get('additional_properties', None)
        self.type = 'Trigger'  # type: str
        self.description = kwargs.get('description', None)
        self.runtime_state = None
        self.annotations = kwargs.get('annotations', None)


class MultiplePipelineTrigger(Trigger):
    """Base class for all triggers that support one to many model for trigger to pipeline.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: BlobEventsTrigger, BlobTrigger, ScheduleTrigger.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param type: Required. Trigger type.Constant filled by server.
    :type type: str
    :param description: Trigger description.
    :type description: str
    :ivar runtime_state: Indicates if trigger is running or not. Updated when Start/Stop APIs are
     called on the Trigger. Possible values include: "Started", "Stopped", "Disabled".
    :vartype runtime_state: str or ~dfaz_management_client.models.TriggerRuntimeState
    :param annotations: List of tags that can be used for describing the trigger.
    :type annotations: list[object]
    :param pipelines: Pipelines that need to be started.
    :type pipelines: list[~dfaz_management_client.models.TriggerPipelineReference]
    """

    _validation = {
        'type': {'required': True},
        'runtime_state': {'readonly': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'type': {'key': 'type', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'runtime_state': {'key': 'runtimeState', 'type': 'str'},
        'annotations': {'key': 'annotations', 'type': '[object]'},
        'pipelines': {'key': 'pipelines', 'type': '[TriggerPipelineReference]'},
    }

    _subtype_map = {
        'type': {'BlobEventsTrigger': 'BlobEventsTrigger', 'BlobTrigger': 'BlobTrigger', 'ScheduleTrigger': 'ScheduleTrigger'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(MultiplePipelineTrigger, self).__init__(**kwargs)
        self.type = 'MultiplePipelineTrigger'  # type: str
        self.pipelines = kwargs.get('pipelines', None)


class BlobEventsTrigger(MultiplePipelineTrigger):
    """Trigger that runs every time a Blob event occurs.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param type: Required. Trigger type.Constant filled by server.
    :type type: str
    :param description: Trigger description.
    :type description: str
    :ivar runtime_state: Indicates if trigger is running or not. Updated when Start/Stop APIs are
     called on the Trigger. Possible values include: "Started", "Stopped", "Disabled".
    :vartype runtime_state: str or ~dfaz_management_client.models.TriggerRuntimeState
    :param annotations: List of tags that can be used for describing the trigger.
    :type annotations: list[object]
    :param pipelines: Pipelines that need to be started.
    :type pipelines: list[~dfaz_management_client.models.TriggerPipelineReference]
    :param blob_path_begins_with: The blob path must begin with the pattern provided for trigger to
     fire. For example, '/records/blobs/december/' will only fire the trigger for blobs in the
     december folder under the records container. At least one of these must be provided:
     blobPathBeginsWith, blobPathEndsWith.
    :type blob_path_begins_with: str
    :param blob_path_ends_with: The blob path must end with the pattern provided for trigger to
     fire. For example, 'december/boxes.csv' will only fire the trigger for blobs named boxes in a
     december folder. At least one of these must be provided: blobPathBeginsWith, blobPathEndsWith.
    :type blob_path_ends_with: str
    :param ignore_empty_blobs: If set to true, blobs with zero bytes will be ignored.
    :type ignore_empty_blobs: bool
    :param events: Required. The type of events that cause this trigger to fire.
    :type events: list[str or ~dfaz_management_client.models.BlobEventTypes]
    :param scope: Required. The ARM resource ID of the Storage Account.
    :type scope: str
    """

    _validation = {
        'type': {'required': True},
        'runtime_state': {'readonly': True},
        'events': {'required': True},
        'scope': {'required': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'type': {'key': 'type', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'runtime_state': {'key': 'runtimeState', 'type': 'str'},
        'annotations': {'key': 'annotations', 'type': '[object]'},
        'pipelines': {'key': 'pipelines', 'type': '[TriggerPipelineReference]'},
        'blob_path_begins_with': {'key': 'typeProperties.blobPathBeginsWith', 'type': 'str'},
        'blob_path_ends_with': {'key': 'typeProperties.blobPathEndsWith', 'type': 'str'},
        'ignore_empty_blobs': {'key': 'typeProperties.ignoreEmptyBlobs', 'type': 'bool'},
        'events': {'key': 'typeProperties.events', 'type': '[str]'},
        'scope': {'key': 'typeProperties.scope', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BlobEventsTrigger, self).__init__(**kwargs)
        self.type = 'BlobEventsTrigger'  # type: str
        self.blob_path_begins_with = kwargs.get('blob_path_begins_with', None)
        self.blob_path_ends_with = kwargs.get('blob_path_ends_with', None)
        self.ignore_empty_blobs = kwargs.get('ignore_empty_blobs', None)
        self.events = kwargs['events']
        self.scope = kwargs['scope']


class BlobTrigger(MultiplePipelineTrigger):
    """Trigger that runs every time the selected Blob container changes.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param type: Required. Trigger type.Constant filled by server.
    :type type: str
    :param description: Trigger description.
    :type description: str
    :ivar runtime_state: Indicates if trigger is running or not. Updated when Start/Stop APIs are
     called on the Trigger. Possible values include: "Started", "Stopped", "Disabled".
    :vartype runtime_state: str or ~dfaz_management_client.models.TriggerRuntimeState
    :param annotations: List of tags that can be used for describing the trigger.
    :type annotations: list[object]
    :param pipelines: Pipelines that need to be started.
    :type pipelines: list[~dfaz_management_client.models.TriggerPipelineReference]
    :param folder_path: Required. The path of the container/folder that will trigger the pipeline.
    :type folder_path: str
    :param max_concurrency: Required. The max number of parallel files to handle when it is
     triggered.
    :type max_concurrency: int
    :param linked_service: Required. The Azure Storage linked service reference.
    :type linked_service: ~dfaz_management_client.models.LinkedServiceReference
    """

    _validation = {
        'type': {'required': True},
        'runtime_state': {'readonly': True},
        'folder_path': {'required': True},
        'max_concurrency': {'required': True},
        'linked_service': {'required': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'type': {'key': 'type', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'runtime_state': {'key': 'runtimeState', 'type': 'str'},
        'annotations': {'key': 'annotations', 'type': '[object]'},
        'pipelines': {'key': 'pipelines', 'type': '[TriggerPipelineReference]'},
        'folder_path': {'key': 'typeProperties.folderPath', 'type': 'str'},
        'max_concurrency': {'key': 'typeProperties.maxConcurrency', 'type': 'int'},
        'linked_service': {'key': 'typeProperties.linkedService', 'type': 'LinkedServiceReference'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BlobTrigger, self).__init__(**kwargs)
        self.type = 'BlobTrigger'  # type: str
        self.folder_path = kwargs['folder_path']
        self.max_concurrency = kwargs['max_concurrency']
        self.linked_service = kwargs['linked_service']


class ChainingTrigger(Trigger):
    """Trigger that allows the referenced pipeline to depend on other pipeline runs based on runDimension Name/Value pairs. Upstream pipelines should declare the same runDimension Name and their runs should have the values for those runDimensions. The referenced pipeline run would be triggered if the values for the runDimension match for all upstream pipeline runs.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param type: Required. Trigger type.Constant filled by server.
    :type type: str
    :param description: Trigger description.
    :type description: str
    :ivar runtime_state: Indicates if trigger is running or not. Updated when Start/Stop APIs are
     called on the Trigger. Possible values include: "Started", "Stopped", "Disabled".
    :vartype runtime_state: str or ~dfaz_management_client.models.TriggerRuntimeState
    :param annotations: List of tags that can be used for describing the trigger.
    :type annotations: list[object]
    :param pipeline: Required. Pipeline for which runs are created when all upstream pipelines
     complete successfully.
    :type pipeline: ~dfaz_management_client.models.TriggerPipelineReference
    :param depends_on: Required. Upstream Pipelines.
    :type depends_on: list[~dfaz_management_client.models.PipelineReference]
    :param run_dimension: Required. Run Dimension property that needs to be emitted by upstream
     pipelines.
    :type run_dimension: str
    """

    _validation = {
        'type': {'required': True},
        'runtime_state': {'readonly': True},
        'pipeline': {'required': True},
        'depends_on': {'required': True},
        'run_dimension': {'required': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'type': {'key': 'type', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'runtime_state': {'key': 'runtimeState', 'type': 'str'},
        'annotations': {'key': 'annotations', 'type': '[object]'},
        'pipeline': {'key': 'pipeline', 'type': 'TriggerPipelineReference'},
        'depends_on': {'key': 'typeProperties.dependsOn', 'type': '[PipelineReference]'},
        'run_dimension': {'key': 'typeProperties.runDimension', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ChainingTrigger, self).__init__(**kwargs)
        self.type = 'ChainingTrigger'  # type: str
        self.pipeline = kwargs['pipeline']
        self.depends_on = kwargs['depends_on']
        self.run_dimension = kwargs['run_dimension']


class CloudError(msrest.serialization.Model):
    """The object that defines the structure of an Azure Data Factory error response.

    All required parameters must be populated in order to send to Azure.

    :param code: Required. Error code.
    :type code: str
    :param message: Required. Error message.
    :type message: str
    :param target: Property name/path in request associated with error.
    :type target: str
    :param details: Array with additional error details.
    :type details: list[~dfaz_management_client.models.CloudError]
    """

    _validation = {
        'code': {'required': True},
        'message': {'required': True},
    }

    _attribute_map = {
        'code': {'key': 'error.code', 'type': 'str'},
        'message': {'key': 'error.message', 'type': 'str'},
        'target': {'key': 'error.target', 'type': 'str'},
        'details': {'key': 'error.details', 'type': '[CloudError]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(CloudError, self).__init__(**kwargs)
        self.code = kwargs['code']
        self.message = kwargs['message']
        self.target = kwargs.get('target', None)
        self.details = kwargs.get('details', None)


class CustomSetupBase(msrest.serialization.Model):
    """The base definition of the custom setup.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: CmdkeySetup, ComponentSetup, EnvironmentVariableSetup.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. The type of custom setup.Constant filled by server.
    :type type: str
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
    }

    _subtype_map = {
        'type': {'CmdkeySetup': 'CmdkeySetup', 'ComponentSetup': 'ComponentSetup', 'EnvironmentVariableSetup': 'EnvironmentVariableSetup'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(CustomSetupBase, self).__init__(**kwargs)
        self.type = None  # type: Optional[str]


class CmdkeySetup(CustomSetupBase):
    """The custom setup of running cmdkey commands.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. The type of custom setup.Constant filled by server.
    :type type: str
    :param target_name: Required. The server name of data source access.
    :type target_name: object
    :param user_name: Required. The user name of data source access.
    :type user_name: object
    :param password: Required. The password of data source access.
    :type password: ~dfaz_management_client.models.SecretBase
    """

    _validation = {
        'type': {'required': True},
        'target_name': {'required': True},
        'user_name': {'required': True},
        'password': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'target_name': {'key': 'typeProperties.targetName', 'type': 'object'},
        'user_name': {'key': 'typeProperties.userName', 'type': 'object'},
        'password': {'key': 'typeProperties.password', 'type': 'SecretBase'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(CmdkeySetup, self).__init__(**kwargs)
        self.type = 'CmdkeySetup'  # type: str
        self.target_name = kwargs['target_name']
        self.user_name = kwargs['user_name']
        self.password = kwargs['password']


class ComponentSetup(CustomSetupBase):
    """The custom setup of installing 3rd party components.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. The type of custom setup.Constant filled by server.
    :type type: str
    :param component_name: Required. The name of the 3rd party component.
    :type component_name: str
    :param license_key: The license key to activate the component.
    :type license_key: ~dfaz_management_client.models.SecretBase
    """

    _validation = {
        'type': {'required': True},
        'component_name': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'component_name': {'key': 'typeProperties.componentName', 'type': 'str'},
        'license_key': {'key': 'typeProperties.licenseKey', 'type': 'SecretBase'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ComponentSetup, self).__init__(**kwargs)
        self.type = 'ComponentSetup'  # type: str
        self.component_name = kwargs['component_name']
        self.license_key = kwargs.get('license_key', None)


class CreateLinkedIntegrationRuntimeRequest(msrest.serialization.Model):
    """The linked integration runtime information.

    :param name: The name of the linked integration runtime.
    :type name: str
    :param subscription_id: The ID of the subscription that the linked integration runtime belongs
     to.
    :type subscription_id: str
    :param data_factory_name: The name of the data factory that the linked integration runtime
     belongs to.
    :type data_factory_name: str
    :param data_factory_location: The location of the data factory that the linked integration
     runtime belongs to.
    :type data_factory_location: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'subscription_id': {'key': 'subscriptionId', 'type': 'str'},
        'data_factory_name': {'key': 'dataFactoryName', 'type': 'str'},
        'data_factory_location': {'key': 'dataFactoryLocation', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(CreateLinkedIntegrationRuntimeRequest, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.subscription_id = kwargs.get('subscription_id', None)
        self.data_factory_name = kwargs.get('data_factory_name', None)
        self.data_factory_location = kwargs.get('data_factory_location', None)


class DependencyReference(msrest.serialization.Model):
    """Referenced dependency.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: SelfDependencyTumblingWindowTriggerReference, TriggerDependencyReference.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. The type of dependency reference.Constant filled by server.
    :type type: str
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
    }

    _subtype_map = {
        'type': {'SelfDependencyTumblingWindowTriggerReference': 'SelfDependencyTumblingWindowTriggerReference', 'TriggerDependencyReference': 'TriggerDependencyReference'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(DependencyReference, self).__init__(**kwargs)
        self.type = None  # type: Optional[str]


class Resource(msrest.serialization.Model):
    """Azure Data Factory top-level resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The resource identifier.
    :vartype id: str
    :ivar name: The resource name.
    :vartype name: str
    :ivar type: The resource type.
    :vartype type: str
    :param location: The resource location.
    :type location: str
    :param tags: A set of tags. The resource tags.
    :type tags: dict[str, str]
    :ivar e_tag: Etag identifies change in the resource.
    :vartype e_tag: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'e_tag': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'e_tag': {'key': 'eTag', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(Resource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.location = kwargs.get('location', None)
        self.tags = kwargs.get('tags', None)
        self.e_tag = None


class DomainService(Resource):
    """Domain service.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The resource identifier.
    :vartype id: str
    :ivar name: The resource name.
    :vartype name: str
    :ivar type: The resource type.
    :vartype type: str
    :param location: The resource location.
    :type location: str
    :param tags: A set of tags. The resource tags.
    :type tags: dict[str, str]
    :ivar e_tag: Etag identifies change in the resource.
    :vartype e_tag: str
    :ivar version: Data Model Version.
    :vartype version: int
    :ivar tenant_id: Azure Active Directory Tenant Id.
    :vartype tenant_id: str
    :param domain_name: The name of the Azure domain that the user would like to deploy Domain
     Services to.
    :type domain_name: str
    :ivar deployment_id: Deployment Id.
    :vartype deployment_id: str
    :ivar sync_owner: SyncOwner ReplicaSet Id.
    :vartype sync_owner: str
    :param replica_sets: List of ReplicaSets.
    :type replica_sets: list[~dfaz_management_client.models.ReplicaSet]
    :param domain_configuration_type: Domain Configuration Type. Possible values include:
     "FullySynced", "ResourceTrusting".
    :type domain_configuration_type: str or
     ~dfaz_management_client.models.DomainServicePropertiesDomainConfigurationType
    :param sku: Sku Type. Possible values include: "Standard", "Enterprise", "Premium".
    :type sku: str or ~dfaz_management_client.models.DomainServicePropertiesSku
    :param filtered_sync: Enabled or Disabled flag to turn on Group-based filtered sync. Possible
     values include: "Enabled", "Disabled".
    :type filtered_sync: str or ~dfaz_management_client.models.FilteredSync
    :ivar provisioning_state: the current deployment or provisioning state, which only appears in
     the response.
    :vartype provisioning_state: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'e_tag': {'readonly': True},
        'version': {'readonly': True},
        'tenant_id': {'readonly': True},
        'deployment_id': {'readonly': True},
        'sync_owner': {'readonly': True},
        'provisioning_state': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'e_tag': {'key': 'eTag', 'type': 'str'},
        'version': {'key': 'properties.version', 'type': 'int'},
        'tenant_id': {'key': 'properties.tenantId', 'type': 'str'},
        'domain_name': {'key': 'properties.domainName', 'type': 'str'},
        'deployment_id': {'key': 'properties.deploymentId', 'type': 'str'},
        'sync_owner': {'key': 'properties.syncOwner', 'type': 'str'},
        'replica_sets': {'key': 'properties.replicaSets', 'type': '[ReplicaSet]'},
        'domain_configuration_type': {'key': 'properties.domainConfigurationType', 'type': 'str'},
        'sku': {'key': 'properties.sku', 'type': 'str'},
        'filtered_sync': {'key': 'properties.filteredSync', 'type': 'str'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(DomainService, self).__init__(**kwargs)
        self.version = None
        self.tenant_id = None
        self.domain_name = kwargs.get('domain_name', None)
        self.deployment_id = None
        self.sync_owner = None
        self.replica_sets = kwargs.get('replica_sets', None)
        self.domain_configuration_type = kwargs.get('domain_configuration_type', None)
        self.sku = kwargs.get('sku', None)
        self.filtered_sync = kwargs.get('filtered_sync', None)
        self.provisioning_state = None


class EntityReference(msrest.serialization.Model):
    """The entity reference.

    :param type: The type of this referenced entity. Possible values include:
     "IntegrationRuntimeReference", "LinkedServiceReference".
    :type type: str or ~dfaz_management_client.models.IntegrationRuntimeEntityReferenceType
    :param reference_name: The name of this referenced entity.
    :type reference_name: str
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'reference_name': {'key': 'referenceName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(EntityReference, self).__init__(**kwargs)
        self.type = kwargs.get('type', None)
        self.reference_name = kwargs.get('reference_name', None)


class EnvironmentVariableSetup(CustomSetupBase):
    """The custom setup of setting environment variable.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. The type of custom setup.Constant filled by server.
    :type type: str
    :param variable_name: Required. The name of the environment variable.
    :type variable_name: str
    :param variable_value: Required. The value of the environment variable.
    :type variable_value: str
    """

    _validation = {
        'type': {'required': True},
        'variable_name': {'required': True},
        'variable_value': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'variable_name': {'key': 'typeProperties.variableName', 'type': 'str'},
        'variable_value': {'key': 'typeProperties.variableValue', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(EnvironmentVariableSetup, self).__init__(**kwargs)
        self.type = 'EnvironmentVariableSetup'  # type: str
        self.variable_name = kwargs['variable_name']
        self.variable_value = kwargs['variable_value']


class Factory(Resource):
    """Factory resource type.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The resource identifier.
    :vartype id: str
    :ivar name: The resource name.
    :vartype name: str
    :ivar type: The resource type.
    :vartype type: str
    :param location: The resource location.
    :type location: str
    :param tags: A set of tags. The resource tags.
    :type tags: dict[str, str]
    :ivar e_tag: Etag identifies change in the resource.
    :vartype e_tag: str
    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param identity: Managed service identity of the factory.
    :type identity: ~dfaz_management_client.models.FactoryIdentity
    :param test_inherit: Test Job Base.
    :type test_inherit: ~dfaz_management_client.models.JobBase
    :ivar provisioning_state: Factory provisioning state, example Succeeded.
    :vartype provisioning_state: str
    :ivar create_time: Time the factory was created in ISO8601 format.
    :vartype create_time: ~datetime.datetime
    :ivar version: Version of the factory.
    :vartype version: str
    :param repo_configuration: Git repo information of the factory.
    :type repo_configuration: ~dfaz_management_client.models.FactoryRepoConfiguration
    :param fake_identity: This is only for az test.
    :type fake_identity: ~dfaz_management_client.models.FakeFactoryIdentity
    :param zones: This is only for az test.
    :type zones: list[str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'e_tag': {'readonly': True},
        'provisioning_state': {'readonly': True},
        'create_time': {'readonly': True},
        'version': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'e_tag': {'key': 'eTag', 'type': 'str'},
        'additional_properties': {'key': '', 'type': '{object}'},
        'identity': {'key': 'identity', 'type': 'FactoryIdentity'},
        'test_inherit': {'key': 'testInherit', 'type': 'JobBase'},
        'provisioning_state': {'key': 'properties.provisioningState', 'type': 'str'},
        'create_time': {'key': 'properties.createTime', 'type': 'iso-8601'},
        'version': {'key': 'properties.version', 'type': 'str'},
        'repo_configuration': {'key': 'properties.repoConfiguration', 'type': 'FactoryRepoConfiguration'},
        'fake_identity': {'key': 'properties.fakeIdentity', 'type': 'FakeFactoryIdentity'},
        'zones': {'key': 'properties.zones', 'type': '[str]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(Factory, self).__init__(**kwargs)
        self.additional_properties = kwargs.get('additional_properties', None)
        self.identity = kwargs.get('identity', None)
        self.test_inherit = kwargs.get('test_inherit', None)
        self.provisioning_state = None
        self.create_time = None
        self.version = None
        self.repo_configuration = kwargs.get('repo_configuration', None)
        self.fake_identity = kwargs.get('fake_identity', None)
        self.zones = kwargs.get('zones', None)


class FactoryRepoConfiguration(msrest.serialization.Model):
    """Factory's git repo information.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: FactoryGitHubConfiguration, FactoryVstsConfiguration.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Type of repo configuration.Constant filled by server.
    :type type: str
    :param account_name: Required. Account name.
    :type account_name: str
    :param repository_name: Required. Repository name.
    :type repository_name: str
    :param collaboration_branch: Required. Collaboration branch.
    :type collaboration_branch: str
    :param root_folder: Required. Root folder.
    :type root_folder: str
    :param last_commit_id: Last commit id.
    :type last_commit_id: str
    """

    _validation = {
        'type': {'required': True},
        'account_name': {'required': True},
        'repository_name': {'required': True},
        'collaboration_branch': {'required': True},
        'root_folder': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'account_name': {'key': 'accountName', 'type': 'str'},
        'repository_name': {'key': 'repositoryName', 'type': 'str'},
        'collaboration_branch': {'key': 'collaborationBranch', 'type': 'str'},
        'root_folder': {'key': 'rootFolder', 'type': 'str'},
        'last_commit_id': {'key': 'lastCommitId', 'type': 'str'},
    }

    _subtype_map = {
        'type': {'FactoryGitHubConfiguration': 'FactoryGitHubConfiguration', 'FactoryVSTSConfiguration': 'FactoryVstsConfiguration'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(FactoryRepoConfiguration, self).__init__(**kwargs)
        self.type = None  # type: Optional[str]
        self.account_name = kwargs['account_name']
        self.repository_name = kwargs['repository_name']
        self.collaboration_branch = kwargs['collaboration_branch']
        self.root_folder = kwargs['root_folder']
        self.last_commit_id = kwargs.get('last_commit_id', None)


class FactoryGitHubConfiguration(FactoryRepoConfiguration):
    """Factory's GitHub repo information.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Type of repo configuration.Constant filled by server.
    :type type: str
    :param account_name: Required. Account name.
    :type account_name: str
    :param repository_name: Required. Repository name.
    :type repository_name: str
    :param collaboration_branch: Required. Collaboration branch.
    :type collaboration_branch: str
    :param root_folder: Required. Root folder.
    :type root_folder: str
    :param last_commit_id: Last commit id.
    :type last_commit_id: str
    :param host_name: GitHub Enterprise host name. For example: https://github.mydomain.com.
    :type host_name: str
    """

    _validation = {
        'type': {'required': True},
        'account_name': {'required': True},
        'repository_name': {'required': True},
        'collaboration_branch': {'required': True},
        'root_folder': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'account_name': {'key': 'accountName', 'type': 'str'},
        'repository_name': {'key': 'repositoryName', 'type': 'str'},
        'collaboration_branch': {'key': 'collaborationBranch', 'type': 'str'},
        'root_folder': {'key': 'rootFolder', 'type': 'str'},
        'last_commit_id': {'key': 'lastCommitId', 'type': 'str'},
        'host_name': {'key': 'hostName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(FactoryGitHubConfiguration, self).__init__(**kwargs)
        self.type = 'FactoryGitHubConfiguration'  # type: str
        self.host_name = kwargs.get('host_name', None)


class FactoryIdentity(msrest.serialization.Model):
    """Identity properties of the factory resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. The identity type. Currently the only supported type is
     'SystemAssigned'. Possible values include: "SystemAssigned".
    :type type: str or ~dfaz_management_client.models.FactoryIdentityType
    :ivar principal_id: The principal id of the identity.
    :vartype principal_id: str
    :ivar tenant_id: The client tenant id of the identity.
    :vartype tenant_id: str
    """

    _validation = {
        'type': {'required': True},
        'principal_id': {'readonly': True},
        'tenant_id': {'readonly': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'principal_id': {'key': 'principalId', 'type': 'str'},
        'tenant_id': {'key': 'tenantId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(FactoryIdentity, self).__init__(**kwargs)
        self.type = kwargs['type']
        self.principal_id = None
        self.tenant_id = None


class FactoryListResponse(msrest.serialization.Model):
    """A list of factory resources.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. List of factories.
    :type value: list[~dfaz_management_client.models.Factory]
    :param next_link: The link to the next page of results, if any remaining results exist.
    :type next_link: str
    """

    _validation = {
        'value': {'required': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[Factory]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(FactoryListResponse, self).__init__(**kwargs)
        self.value = kwargs['value']
        self.next_link = kwargs.get('next_link', None)


class FactoryRepoUpdate(msrest.serialization.Model):
    """Factory's git repo information.

    :param factory_resource_id: The factory resource id.
    :type factory_resource_id: str
    :param repo_configuration: Git repo information of the factory.
    :type repo_configuration: ~dfaz_management_client.models.FactoryRepoConfiguration
    """

    _attribute_map = {
        'factory_resource_id': {'key': 'factoryResourceId', 'type': 'str'},
        'repo_configuration': {'key': 'repoConfiguration', 'type': 'FactoryRepoConfiguration'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(FactoryRepoUpdate, self).__init__(**kwargs)
        self.factory_resource_id = kwargs.get('factory_resource_id', None)
        self.repo_configuration = kwargs.get('repo_configuration', None)


class FactoryUpdateParameters(msrest.serialization.Model):
    """Parameters for updating a factory resource.

    All required parameters must be populated in order to send to Azure.

    :param tags: A set of tags. The resource tags.
    :type tags: dict[str, str]
    :param identity: Required. Managed service identity of the factory.
    :type identity: ~dfaz_management_client.models.FactoryIdentity
    """

    _validation = {
        'identity': {'required': True},
    }

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '{str}'},
        'identity': {'key': 'identity', 'type': 'FactoryIdentity'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(FactoryUpdateParameters, self).__init__(**kwargs)
        self.tags = kwargs.get('tags', None)
        self.identity = kwargs['identity']


class FactoryVstsConfiguration(FactoryRepoConfiguration):
    """Factory's VSTS repo information.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Type of repo configuration.Constant filled by server.
    :type type: str
    :param account_name: Required. Account name.
    :type account_name: str
    :param repository_name: Required. Repository name.
    :type repository_name: str
    :param collaboration_branch: Required. Collaboration branch.
    :type collaboration_branch: str
    :param root_folder: Required. Root folder.
    :type root_folder: str
    :param last_commit_id: Last commit id.
    :type last_commit_id: str
    :param project_name: Required. VSTS project name.
    :type project_name: str
    :param tenant_id: VSTS tenant id.
    :type tenant_id: str
    """

    _validation = {
        'type': {'required': True},
        'account_name': {'required': True},
        'repository_name': {'required': True},
        'collaboration_branch': {'required': True},
        'root_folder': {'required': True},
        'project_name': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'account_name': {'key': 'accountName', 'type': 'str'},
        'repository_name': {'key': 'repositoryName', 'type': 'str'},
        'collaboration_branch': {'key': 'collaborationBranch', 'type': 'str'},
        'root_folder': {'key': 'rootFolder', 'type': 'str'},
        'last_commit_id': {'key': 'lastCommitId', 'type': 'str'},
        'project_name': {'key': 'projectName', 'type': 'str'},
        'tenant_id': {'key': 'tenantId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(FactoryVstsConfiguration, self).__init__(**kwargs)
        self.type = 'FactoryVSTSConfiguration'  # type: str
        self.project_name = kwargs['project_name']
        self.tenant_id = kwargs.get('tenant_id', None)


class FakeFactoryIdentity(msrest.serialization.Model):
    """This is only for az test.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. ..
    :type name: str
    :param zones_inside: sample of simple array.
    :type zones_inside: list[str]
    """

    _validation = {
        'name': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'zones_inside': {'key': 'zonesInside', 'type': '[str]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(FakeFactoryIdentity, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.zones_inside = kwargs.get('zones_inside', None)


class GitHubAccessTokenRequest(msrest.serialization.Model):
    """Get GitHub access token request definition.

    All required parameters must be populated in order to send to Azure.

    :param git_hub_access_code: Required. GitHub access code.
    :type git_hub_access_code: str
    :param git_hub_client_id: GitHub application client ID.
    :type git_hub_client_id: str
    :param git_hub_access_token_base_url: Required. GitHub access token base URL.
    :type git_hub_access_token_base_url: str
    """

    _validation = {
        'git_hub_access_code': {'required': True},
        'git_hub_access_token_base_url': {'required': True},
    }

    _attribute_map = {
        'git_hub_access_code': {'key': 'gitHubAccessCode', 'type': 'str'},
        'git_hub_client_id': {'key': 'gitHubClientId', 'type': 'str'},
        'git_hub_access_token_base_url': {'key': 'gitHubAccessTokenBaseUrl', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(GitHubAccessTokenRequest, self).__init__(**kwargs)
        self.git_hub_access_code = kwargs['git_hub_access_code']
        self.git_hub_client_id = kwargs.get('git_hub_client_id', None)
        self.git_hub_access_token_base_url = kwargs['git_hub_access_token_base_url']


class GitHubAccessTokenResponse(msrest.serialization.Model):
    """Get GitHub access token response definition.

    :param git_hub_access_token: GitHub access token.
    :type git_hub_access_token: str
    """

    _attribute_map = {
        'git_hub_access_token': {'key': 'gitHubAccessToken', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(GitHubAccessTokenResponse, self).__init__(**kwargs)
        self.git_hub_access_token = kwargs.get('git_hub_access_token', None)


class Group(msrest.serialization.Model):
    """A group created in a Migration project.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Path reference to this group.
     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Migrate/assessmentProjects/{projectName}/groups/{groupName}.
    :vartype id: str
    :ivar name: Name of the group.
    :vartype name: str
    :param e_tag: For optimistic concurrency control.
    :type e_tag: str
    :ivar type: Type of the object = [Microsoft.Migrate/assessmentProjects/groups].
    :vartype type: str
    :param properties: Required. Properties of the group.
    :type properties: ~dfaz_management_client.models.GroupProperties
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'properties': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'e_tag': {'key': 'eTag', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'GroupProperties'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(Group, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.e_tag = kwargs.get('e_tag', None)
        self.type = None
        self.properties = kwargs['properties']


class GroupProperties(msrest.serialization.Model):
    """Properties of group resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar group_status: Whether the group has been created and is valid. Possible values include:
     "Created", "Updated", "Running", "Completed", "Invalid".
    :vartype group_status: str or ~dfaz_management_client.models.GroupStatus
    :ivar machine_count: Number of machines part of this group.
    :vartype machine_count: int
    :ivar assessments: List of References to Assessments created on this group.
    :vartype assessments: list[str]
    :ivar are_assessments_running: If the assessments are in running state.
    :vartype are_assessments_running: bool
    :ivar created_timestamp: Time when this group was created. Date-Time represented in ISO-8601
     format.
    :vartype created_timestamp: ~datetime.datetime
    :ivar updated_timestamp: Time when this group was last updated. Date-Time represented in
     ISO-8601 format.
    :vartype updated_timestamp: ~datetime.datetime
    """

    _validation = {
        'group_status': {'readonly': True},
        'machine_count': {'readonly': True},
        'assessments': {'readonly': True},
        'are_assessments_running': {'readonly': True},
        'created_timestamp': {'readonly': True},
        'updated_timestamp': {'readonly': True},
    }

    _attribute_map = {
        'group_status': {'key': 'groupStatus', 'type': 'str'},
        'machine_count': {'key': 'machineCount', 'type': 'int'},
        'assessments': {'key': 'assessments', 'type': '[str]'},
        'are_assessments_running': {'key': 'areAssessmentsRunning', 'type': 'bool'},
        'created_timestamp': {'key': 'createdTimestamp', 'type': 'iso-8601'},
        'updated_timestamp': {'key': 'updatedTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(GroupProperties, self).__init__(**kwargs)
        self.group_status = None
        self.machine_count = None
        self.assessments = None
        self.are_assessments_running = None
        self.created_timestamp = None
        self.updated_timestamp = None


class HealthAlert(msrest.serialization.Model):
    """Health Alert Description.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Health Alert Id.
    :vartype id: str
    :ivar name: Health Alert Name.
    :vartype name: str
    :ivar issue: Health Alert Issue.
    :vartype issue: str
    :ivar severity: Health Alert Severity.
    :vartype severity: str
    :ivar raised: Health Alert Raised DateTime.
    :vartype raised: ~datetime.datetime
    :ivar last_detected: Health Alert Last Detected DateTime.
    :vartype last_detected: ~datetime.datetime
    :ivar resolution_uri: Health Alert TSG Link.
    :vartype resolution_uri: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'issue': {'readonly': True},
        'severity': {'readonly': True},
        'raised': {'readonly': True},
        'last_detected': {'readonly': True},
        'resolution_uri': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'issue': {'key': 'issue', 'type': 'str'},
        'severity': {'key': 'severity', 'type': 'str'},
        'raised': {'key': 'raised', 'type': 'iso-8601'},
        'last_detected': {'key': 'lastDetected', 'type': 'iso-8601'},
        'resolution_uri': {'key': 'resolutionUri', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(HealthAlert, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.issue = None
        self.severity = None
        self.raised = None
        self.last_detected = None
        self.resolution_uri = None


class HealthMonitor(msrest.serialization.Model):
    """Health Monitor Description.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: Health Monitor Id.
    :vartype id: str
    :ivar name: Health Monitor Name.
    :vartype name: str
    :ivar details: Health Monitor Details.
    :vartype details: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'details': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'details': {'key': 'details', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(HealthMonitor, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.details = None


class IntegrationRuntime(msrest.serialization.Model):
    """Azure Data Factory nested object which serves as a compute resource for activities.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ManagedIntegrationRuntime, SelfHostedIntegrationRuntime.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param type: Required. Type of integration runtime.Constant filled by server.  Possible values
     include: "Managed", "SelfHosted".
    :type type: str or ~dfaz_management_client.models.IntegrationRuntimeType
    :param description: Integration runtime description.
    :type description: str
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'type': {'key': 'type', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    _subtype_map = {
        'type': {'Managed': 'ManagedIntegrationRuntime', 'SelfHosted': 'SelfHostedIntegrationRuntime'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntime, self).__init__(**kwargs)
        self.additional_properties = kwargs.get('additional_properties', None)
        self.type = 'IntegrationRuntime'  # type: str
        self.description = kwargs.get('description', None)


class IntegrationRuntimeAuthKeys(msrest.serialization.Model):
    """The integration runtime authentication keys.

    :param auth_key1: The primary integration runtime authentication key.
    :type auth_key1: str
    :param auth_key2: The secondary integration runtime authentication key.
    :type auth_key2: str
    """

    _attribute_map = {
        'auth_key1': {'key': 'authKey1', 'type': 'str'},
        'auth_key2': {'key': 'authKey2', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntimeAuthKeys, self).__init__(**kwargs)
        self.auth_key1 = kwargs.get('auth_key1', None)
        self.auth_key2 = kwargs.get('auth_key2', None)


class IntegrationRuntimeComputeProperties(msrest.serialization.Model):
    """The compute resource properties for managed integration runtime.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param location: The location for managed integration runtime. The supported regions could be
     found on https://docs.microsoft.com/en-us/azure/data-factory/data-factory-data-movement-
     activities.
    :type location: str
    :param node_size: The node size requirement to managed integration runtime.
    :type node_size: str
    :param number_of_nodes: The required number of nodes for managed integration runtime.
    :type number_of_nodes: int
    :param max_parallel_executions_per_node: Maximum parallel executions count per node for managed
     integration runtime.
    :type max_parallel_executions_per_node: int
    :param data_flow_properties: Data flow properties for managed integration runtime.
    :type data_flow_properties: ~dfaz_management_client.models.IntegrationRuntimeDataFlowProperties
    :param v_net_properties: VNet properties for managed integration runtime.
    :type v_net_properties: ~dfaz_management_client.models.IntegrationRuntimeVNetProperties
    """

    _validation = {
        'number_of_nodes': {'minimum': 1},
        'max_parallel_executions_per_node': {'minimum': 1},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'location': {'key': 'location', 'type': 'str'},
        'node_size': {'key': 'nodeSize', 'type': 'str'},
        'number_of_nodes': {'key': 'numberOfNodes', 'type': 'int'},
        'max_parallel_executions_per_node': {'key': 'maxParallelExecutionsPerNode', 'type': 'int'},
        'data_flow_properties': {'key': 'dataFlowProperties', 'type': 'IntegrationRuntimeDataFlowProperties'},
        'v_net_properties': {'key': 'vNetProperties', 'type': 'IntegrationRuntimeVNetProperties'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntimeComputeProperties, self).__init__(**kwargs)
        self.additional_properties = kwargs.get('additional_properties', None)
        self.location = kwargs.get('location', None)
        self.node_size = kwargs.get('node_size', None)
        self.number_of_nodes = kwargs.get('number_of_nodes', None)
        self.max_parallel_executions_per_node = kwargs.get('max_parallel_executions_per_node', None)
        self.data_flow_properties = kwargs.get('data_flow_properties', None)
        self.v_net_properties = kwargs.get('v_net_properties', None)


class IntegrationRuntimeConnectionInfo(msrest.serialization.Model):
    """Connection information for encrypting the on-premises data source credentials.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :ivar service_token: The token generated in service. Callers use this token to authenticate to
     integration runtime.
    :vartype service_token: str
    :ivar identity_cert_thumbprint: The integration runtime SSL certificate thumbprint. Click-Once
     application uses it to do server validation.
    :vartype identity_cert_thumbprint: str
    :ivar host_service_uri: The on-premises integration runtime host URL.
    :vartype host_service_uri: str
    :ivar version: The integration runtime version.
    :vartype version: str
    :ivar public_key: The public key for encrypting a credential when transferring the credential
     to the integration runtime.
    :vartype public_key: str
    :ivar is_identity_cert_exprired: Whether the identity certificate is expired.
    :vartype is_identity_cert_exprired: bool
    """

    _validation = {
        'service_token': {'readonly': True},
        'identity_cert_thumbprint': {'readonly': True},
        'host_service_uri': {'readonly': True},
        'version': {'readonly': True},
        'public_key': {'readonly': True},
        'is_identity_cert_exprired': {'readonly': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'service_token': {'key': 'serviceToken', 'type': 'str'},
        'identity_cert_thumbprint': {'key': 'identityCertThumbprint', 'type': 'str'},
        'host_service_uri': {'key': 'hostServiceUri', 'type': 'str'},
        'version': {'key': 'version', 'type': 'str'},
        'public_key': {'key': 'publicKey', 'type': 'str'},
        'is_identity_cert_exprired': {'key': 'isIdentityCertExprired', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntimeConnectionInfo, self).__init__(**kwargs)
        self.additional_properties = kwargs.get('additional_properties', None)
        self.service_token = None
        self.identity_cert_thumbprint = None
        self.host_service_uri = None
        self.version = None
        self.public_key = None
        self.is_identity_cert_exprired = None


class IntegrationRuntimeCustomSetupScriptProperties(msrest.serialization.Model):
    """Custom setup script properties for a managed dedicated integration runtime.

    :param blob_container_uri: The URI of the Azure blob container that contains the custom setup
     script.
    :type blob_container_uri: str
    :param sas_token: The SAS token of the Azure blob container.
    :type sas_token: ~dfaz_management_client.models.SecureString
    """

    _attribute_map = {
        'blob_container_uri': {'key': 'blobContainerUri', 'type': 'str'},
        'sas_token': {'key': 'sasToken', 'type': 'SecureString'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntimeCustomSetupScriptProperties, self).__init__(**kwargs)
        self.blob_container_uri = kwargs.get('blob_container_uri', None)
        self.sas_token = kwargs.get('sas_token', None)


class IntegrationRuntimeDataFlowProperties(msrest.serialization.Model):
    """Data flow properties for managed integration runtime.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param compute_type: Compute type of the cluster which will execute data flow job. Possible
     values include: "General", "MemoryOptimized", "ComputeOptimized".
    :type compute_type: str or ~dfaz_management_client.models.DataFlowComputeType
    :param core_count: Core count of the cluster which will execute data flow job. Supported values
     are: 8, 16, 32, 48, 80, 144 and 272.
    :type core_count: int
    :param time_to_live: Time to live (in minutes) setting of the cluster which will execute data
     flow job.
    :type time_to_live: int
    """

    _validation = {
        'time_to_live': {'minimum': 0},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'compute_type': {'key': 'computeType', 'type': 'str'},
        'core_count': {'key': 'coreCount', 'type': 'int'},
        'time_to_live': {'key': 'timeToLive', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntimeDataFlowProperties, self).__init__(**kwargs)
        self.additional_properties = kwargs.get('additional_properties', None)
        self.compute_type = kwargs.get('compute_type', None)
        self.core_count = kwargs.get('core_count', None)
        self.time_to_live = kwargs.get('time_to_live', None)


class IntegrationRuntimeDataProxyProperties(msrest.serialization.Model):
    """Data proxy properties for a managed dedicated integration runtime.

    :param connect_via: The self-hosted integration runtime reference.
    :type connect_via: ~dfaz_management_client.models.EntityReference
    :param staging_linked_service: The staging linked service reference.
    :type staging_linked_service: ~dfaz_management_client.models.EntityReference
    :param path: The path to contain the staged data in the Blob storage.
    :type path: str
    """

    _attribute_map = {
        'connect_via': {'key': 'connectVia', 'type': 'EntityReference'},
        'staging_linked_service': {'key': 'stagingLinkedService', 'type': 'EntityReference'},
        'path': {'key': 'path', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntimeDataProxyProperties, self).__init__(**kwargs)
        self.connect_via = kwargs.get('connect_via', None)
        self.staging_linked_service = kwargs.get('staging_linked_service', None)
        self.path = kwargs.get('path', None)


class IntegrationRuntimeListResponse(msrest.serialization.Model):
    """A list of integration runtime resources.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. List of integration runtimes.
    :type value: list[~dfaz_management_client.models.IntegrationRuntimeResource]
    :param next_link: The link to the next page of results, if any remaining results exist.
    :type next_link: str
    """

    _validation = {
        'value': {'required': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[IntegrationRuntimeResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntimeListResponse, self).__init__(**kwargs)
        self.value = kwargs['value']
        self.next_link = kwargs.get('next_link', None)


class IntegrationRuntimeMonitoringData(msrest.serialization.Model):
    """Get monitoring data response.

    :param name: Integration runtime name.
    :type name: str
    :param nodes: Integration runtime node monitoring data.
    :type nodes: list[~dfaz_management_client.models.IntegrationRuntimeNodeMonitoringData]
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'nodes': {'key': 'nodes', 'type': '[IntegrationRuntimeNodeMonitoringData]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntimeMonitoringData, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.nodes = kwargs.get('nodes', None)


class IntegrationRuntimeNodeIpAddress(msrest.serialization.Model):
    """The IP address of self-hosted integration runtime node.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar ip_address: The IP address of self-hosted integration runtime node.
    :vartype ip_address: str
    """

    _validation = {
        'ip_address': {'readonly': True},
    }

    _attribute_map = {
        'ip_address': {'key': 'ipAddress', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntimeNodeIpAddress, self).__init__(**kwargs)
        self.ip_address = None


class IntegrationRuntimeNodeMonitoringData(msrest.serialization.Model):
    """Monitoring data for integration runtime node.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :ivar node_name: Name of the integration runtime node.
    :vartype node_name: str
    :ivar available_memory_in_mb: Available memory (MB) on the integration runtime node.
    :vartype available_memory_in_mb: int
    :ivar cpu_utilization: CPU percentage on the integration runtime node.
    :vartype cpu_utilization: int
    :ivar concurrent_jobs_limit: Maximum concurrent jobs on the integration runtime node.
    :vartype concurrent_jobs_limit: int
    :ivar concurrent_jobs_running: The number of jobs currently running on the integration runtime
     node.
    :vartype concurrent_jobs_running: int
    :ivar max_concurrent_jobs: The maximum concurrent jobs in this integration runtime.
    :vartype max_concurrent_jobs: int
    :ivar sent_bytes: Sent bytes on the integration runtime node.
    :vartype sent_bytes: float
    :ivar received_bytes: Received bytes on the integration runtime node.
    :vartype received_bytes: float
    """

    _validation = {
        'node_name': {'readonly': True},
        'available_memory_in_mb': {'readonly': True},
        'cpu_utilization': {'readonly': True},
        'concurrent_jobs_limit': {'readonly': True},
        'concurrent_jobs_running': {'readonly': True},
        'max_concurrent_jobs': {'readonly': True},
        'sent_bytes': {'readonly': True},
        'received_bytes': {'readonly': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'node_name': {'key': 'nodeName', 'type': 'str'},
        'available_memory_in_mb': {'key': 'availableMemoryInMB', 'type': 'int'},
        'cpu_utilization': {'key': 'cpuUtilization', 'type': 'int'},
        'concurrent_jobs_limit': {'key': 'concurrentJobsLimit', 'type': 'int'},
        'concurrent_jobs_running': {'key': 'concurrentJobsRunning', 'type': 'int'},
        'max_concurrent_jobs': {'key': 'maxConcurrentJobs', 'type': 'int'},
        'sent_bytes': {'key': 'sentBytes', 'type': 'float'},
        'received_bytes': {'key': 'receivedBytes', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntimeNodeMonitoringData, self).__init__(**kwargs)
        self.additional_properties = kwargs.get('additional_properties', None)
        self.node_name = None
        self.available_memory_in_mb = None
        self.cpu_utilization = None
        self.concurrent_jobs_limit = None
        self.concurrent_jobs_running = None
        self.max_concurrent_jobs = None
        self.sent_bytes = None
        self.received_bytes = None


class IntegrationRuntimeReference(msrest.serialization.Model):
    """Integration runtime reference type.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. Type of integration runtime. Default value:
     "IntegrationRuntimeReference".
    :vartype type: str
    :param reference_name: Required. Reference integration runtime name.
    :type reference_name: str
    :param parameters: Arguments for integration runtime.
    :type parameters: dict[str, object]
    """

    _validation = {
        'type': {'required': True, 'constant': True},
        'reference_name': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'reference_name': {'key': 'referenceName', 'type': 'str'},
        'parameters': {'key': 'parameters', 'type': '{object}'},
    }

    type = "IntegrationRuntimeReference"

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntimeReference, self).__init__(**kwargs)
        self.reference_name = kwargs['reference_name']
        self.parameters = kwargs.get('parameters', None)


class IntegrationRuntimeRegenerateKeyParameters(msrest.serialization.Model):
    """Parameters to regenerate the authentication key.

    :param key_name: The name of the authentication key to regenerate. Possible values include:
     "authKey1", "authKey2".
    :type key_name: str or ~dfaz_management_client.models.IntegrationRuntimeAuthKeyName
    """

    _attribute_map = {
        'key_name': {'key': 'keyName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntimeRegenerateKeyParameters, self).__init__(**kwargs)
        self.key_name = kwargs.get('key_name', None)


class SubResource(msrest.serialization.Model):
    """Azure Data Factory nested resource, which belongs to a factory.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The resource identifier.
    :vartype id: str
    :ivar name: The resource name.
    :vartype name: str
    :ivar type: The resource type.
    :vartype type: str
    :ivar etag: Etag identifies change in the resource.
    :vartype etag: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'etag': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'etag': {'key': 'etag', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SubResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.etag = None


class IntegrationRuntimeResource(SubResource):
    """Integration runtime resource type.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: The resource identifier.
    :vartype id: str
    :ivar name: The resource name.
    :vartype name: str
    :ivar type: The resource type.
    :vartype type: str
    :ivar etag: Etag identifies change in the resource.
    :vartype etag: str
    :param properties: Required. Integration runtime properties.
    :type properties: ~dfaz_management_client.models.IntegrationRuntime
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'etag': {'readonly': True},
        'properties': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'etag': {'key': 'etag', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'IntegrationRuntime'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntimeResource, self).__init__(**kwargs)
        self.properties = kwargs['properties']


class IntegrationRuntimeSsisCatalogInfo(msrest.serialization.Model):
    """Catalog information for managed dedicated integration runtime.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param catalog_server_endpoint: The catalog database server URL.
    :type catalog_server_endpoint: str
    :param catalog_admin_user_name: The administrator user name of catalog database.
    :type catalog_admin_user_name: str
    :param catalog_admin_password: The password of the administrator user account of the catalog
     database.
    :type catalog_admin_password: ~dfaz_management_client.models.SecureString
    :param catalog_pricing_tier: The pricing tier for the catalog database. The valid values could
     be found in https://azure.microsoft.com/en-us/pricing/details/sql-database/. Possible values
     include: "Basic", "Standard", "Premium", "PremiumRS".
    :type catalog_pricing_tier: str or
     ~dfaz_management_client.models.IntegrationRuntimeSsisCatalogPricingTier
    """

    _validation = {
        'catalog_admin_user_name': {'max_length': 128, 'min_length': 1},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'catalog_server_endpoint': {'key': 'catalogServerEndpoint', 'type': 'str'},
        'catalog_admin_user_name': {'key': 'catalogAdminUserName', 'type': 'str'},
        'catalog_admin_password': {'key': 'catalogAdminPassword', 'type': 'SecureString'},
        'catalog_pricing_tier': {'key': 'catalogPricingTier', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntimeSsisCatalogInfo, self).__init__(**kwargs)
        self.additional_properties = kwargs.get('additional_properties', None)
        self.catalog_server_endpoint = kwargs.get('catalog_server_endpoint', None)
        self.catalog_admin_user_name = kwargs.get('catalog_admin_user_name', None)
        self.catalog_admin_password = kwargs.get('catalog_admin_password', None)
        self.catalog_pricing_tier = kwargs.get('catalog_pricing_tier', None)


class IntegrationRuntimeSsisProperties(msrest.serialization.Model):
    """SSIS properties for managed integration runtime.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param catalog_info: Catalog information for managed dedicated integration runtime.
    :type catalog_info: ~dfaz_management_client.models.IntegrationRuntimeSsisCatalogInfo
    :param license_type: License type for bringing your own license scenario. Possible values
     include: "BasePrice", "LicenseIncluded".
    :type license_type: str or ~dfaz_management_client.models.IntegrationRuntimeLicenseType
    :param custom_setup_script_properties: Custom setup script properties for a managed dedicated
     integration runtime.
    :type custom_setup_script_properties:
     ~dfaz_management_client.models.IntegrationRuntimeCustomSetupScriptProperties
    :param data_proxy_properties: Data proxy properties for a managed dedicated integration
     runtime.
    :type data_proxy_properties:
     ~dfaz_management_client.models.IntegrationRuntimeDataProxyProperties
    :param edition: The edition for the SSIS Integration Runtime. Possible values include:
     "Standard", "Enterprise".
    :type edition: str or ~dfaz_management_client.models.IntegrationRuntimeEdition
    :param express_custom_setup_properties: Custom setup without script properties for a SSIS
     integration runtime.
    :type express_custom_setup_properties: list[~dfaz_management_client.models.CustomSetupBase]
    :param package_stores: Package stores for the SSIS Integration Runtime.
    :type package_stores: list[~dfaz_management_client.models.PackageStore]
    """

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'catalog_info': {'key': 'catalogInfo', 'type': 'IntegrationRuntimeSsisCatalogInfo'},
        'license_type': {'key': 'licenseType', 'type': 'str'},
        'custom_setup_script_properties': {'key': 'customSetupScriptProperties', 'type': 'IntegrationRuntimeCustomSetupScriptProperties'},
        'data_proxy_properties': {'key': 'dataProxyProperties', 'type': 'IntegrationRuntimeDataProxyProperties'},
        'edition': {'key': 'edition', 'type': 'str'},
        'express_custom_setup_properties': {'key': 'expressCustomSetupProperties', 'type': '[CustomSetupBase]'},
        'package_stores': {'key': 'packageStores', 'type': '[PackageStore]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntimeSsisProperties, self).__init__(**kwargs)
        self.additional_properties = kwargs.get('additional_properties', None)
        self.catalog_info = kwargs.get('catalog_info', None)
        self.license_type = kwargs.get('license_type', None)
        self.custom_setup_script_properties = kwargs.get('custom_setup_script_properties', None)
        self.data_proxy_properties = kwargs.get('data_proxy_properties', None)
        self.edition = kwargs.get('edition', None)
        self.express_custom_setup_properties = kwargs.get('express_custom_setup_properties', None)
        self.package_stores = kwargs.get('package_stores', None)


class IntegrationRuntimeStatus(msrest.serialization.Model):
    """Integration runtime status.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ManagedIntegrationRuntimeStatus, SelfHostedIntegrationRuntimeStatus.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param type: Required. Type of integration runtime.Constant filled by server.  Possible values
     include: "Managed", "SelfHosted".
    :type type: str or ~dfaz_management_client.models.IntegrationRuntimeType
    :ivar data_factory_name: The data factory name which the integration runtime belong to.
    :vartype data_factory_name: str
    :ivar state: The state of integration runtime. Possible values include: "Initial", "Stopped",
     "Started", "Starting", "Stopping", "NeedRegistration", "Online", "Limited", "Offline",
     "AccessDenied".
    :vartype state: str or ~dfaz_management_client.models.IntegrationRuntimeState
    """

    _validation = {
        'type': {'required': True},
        'data_factory_name': {'readonly': True},
        'state': {'readonly': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'type': {'key': 'type', 'type': 'str'},
        'data_factory_name': {'key': 'dataFactoryName', 'type': 'str'},
        'state': {'key': 'state', 'type': 'str'},
    }

    _subtype_map = {
        'type': {'Managed': 'ManagedIntegrationRuntimeStatus', 'SelfHosted': 'SelfHostedIntegrationRuntimeStatus'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntimeStatus, self).__init__(**kwargs)
        self.additional_properties = kwargs.get('additional_properties', None)
        self.type = 'IntegrationRuntimeStatus'  # type: str
        self.data_factory_name = None
        self.state = None


class IntegrationRuntimeStatusListResponse(msrest.serialization.Model):
    """A list of integration runtime status.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. List of integration runtime status.
    :type value: list[~dfaz_management_client.models.IntegrationRuntimeStatusResponse]
    :param next_link: The link to the next page of results, if any remaining results exist.
    :type next_link: str
    """

    _validation = {
        'value': {'required': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[IntegrationRuntimeStatusResponse]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntimeStatusListResponse, self).__init__(**kwargs)
        self.value = kwargs['value']
        self.next_link = kwargs.get('next_link', None)


class IntegrationRuntimeStatusResponse(msrest.serialization.Model):
    """Integration runtime status response.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar name: The integration runtime name.
    :vartype name: str
    :param properties: Required. Integration runtime properties.
    :type properties: ~dfaz_management_client.models.IntegrationRuntimeStatus
    """

    _validation = {
        'name': {'readonly': True},
        'properties': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'IntegrationRuntimeStatus'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntimeStatusResponse, self).__init__(**kwargs)
        self.name = None
        self.properties = kwargs['properties']


class IntegrationRuntimeVNetProperties(msrest.serialization.Model):
    """VNet properties for managed integration runtime.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param v_net_id: The ID of the VNet that this integration runtime will join.
    :type v_net_id: str
    :param subnet: The name of the subnet this integration runtime will join.
    :type subnet: str
    :param public_i_ps: Resource IDs of the public IP addresses that this integration runtime will
     use.
    :type public_i_ps: list[str]
    """

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'v_net_id': {'key': 'vNetId', 'type': 'str'},
        'subnet': {'key': 'subnet', 'type': 'str'},
        'public_i_ps': {'key': 'publicIPs', 'type': '[str]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(IntegrationRuntimeVNetProperties, self).__init__(**kwargs)
        self.additional_properties = kwargs.get('additional_properties', None)
        self.v_net_id = kwargs.get('v_net_id', None)
        self.subnet = kwargs.get('subnet', None)
        self.public_i_ps = kwargs.get('public_i_ps', None)


class JobBaseInteractionEndpoints(msrest.serialization.Model):
    """Dictonary of endpoint URIs, keyed by enumerated JobEndpoints, can be added, removed or updated.

    :param tracking:
    :type tracking: str
    :param studio:
    :type studio: str
    :param grafana:
    :type grafana: str
    :param tensorboard:
    :type tensorboard: str
    """

    _attribute_map = {
        'tracking': {'key': 'Tracking', 'type': 'str'},
        'studio': {'key': 'Studio', 'type': 'str'},
        'grafana': {'key': 'Grafana', 'type': 'str'},
        'tensorboard': {'key': 'Tensorboard', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(JobBaseInteractionEndpoints, self).__init__(**kwargs)
        self.tracking = kwargs.get('tracking', None)
        self.studio = kwargs.get('studio', None)
        self.grafana = kwargs.get('grafana', None)
        self.tensorboard = kwargs.get('tensorboard', None)


class LinkedIntegrationRuntime(msrest.serialization.Model):
    """The linked integration runtime information.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar name: The name of the linked integration runtime.
    :vartype name: str
    :ivar subscription_id: The subscription ID for which the linked integration runtime belong to.
    :vartype subscription_id: str
    :ivar data_factory_name: The name of the data factory for which the linked integration runtime
     belong to.
    :vartype data_factory_name: str
    :ivar data_factory_location: The location of the data factory for which the linked integration
     runtime belong to.
    :vartype data_factory_location: str
    :ivar create_time: The creating time of the linked integration runtime.
    :vartype create_time: ~datetime.datetime
    """

    _validation = {
        'name': {'readonly': True},
        'subscription_id': {'readonly': True},
        'data_factory_name': {'readonly': True},
        'data_factory_location': {'readonly': True},
        'create_time': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'subscription_id': {'key': 'subscriptionId', 'type': 'str'},
        'data_factory_name': {'key': 'dataFactoryName', 'type': 'str'},
        'data_factory_location': {'key': 'dataFactoryLocation', 'type': 'str'},
        'create_time': {'key': 'createTime', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(LinkedIntegrationRuntime, self).__init__(**kwargs)
        self.name = None
        self.subscription_id = None
        self.data_factory_name = None
        self.data_factory_location = None
        self.create_time = None


class LinkedIntegrationRuntimeType(msrest.serialization.Model):
    """The base definition of a linked integration runtime.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: LinkedIntegrationRuntimeKeyAuthorization, LinkedIntegrationRuntimeRbacAuthorization.

    All required parameters must be populated in order to send to Azure.

    :param authorization_type: Required. The authorization type for integration runtime
     sharing.Constant filled by server.
    :type authorization_type: str
    """

    _validation = {
        'authorization_type': {'required': True},
    }

    _attribute_map = {
        'authorization_type': {'key': 'authorizationType', 'type': 'str'},
    }

    _subtype_map = {
        'authorization_type': {'Key': 'LinkedIntegrationRuntimeKeyAuthorization', 'RBAC': 'LinkedIntegrationRuntimeRbacAuthorization'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(LinkedIntegrationRuntimeType, self).__init__(**kwargs)
        self.authorization_type = None  # type: Optional[str]


class LinkedIntegrationRuntimeKeyAuthorization(LinkedIntegrationRuntimeType):
    """The key authorization type integration runtime.

    All required parameters must be populated in order to send to Azure.

    :param authorization_type: Required. The authorization type for integration runtime
     sharing.Constant filled by server.
    :type authorization_type: str
    :param key: Required. The key used for authorization.
    :type key: ~dfaz_management_client.models.SecureString
    """

    _validation = {
        'authorization_type': {'required': True},
        'key': {'required': True},
    }

    _attribute_map = {
        'authorization_type': {'key': 'authorizationType', 'type': 'str'},
        'key': {'key': 'key', 'type': 'SecureString'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(LinkedIntegrationRuntimeKeyAuthorization, self).__init__(**kwargs)
        self.authorization_type = 'Key'  # type: str
        self.key = kwargs['key']


class LinkedIntegrationRuntimeRbacAuthorization(LinkedIntegrationRuntimeType):
    """The role based access control (RBAC) authorization type integration runtime.

    All required parameters must be populated in order to send to Azure.

    :param authorization_type: Required. The authorization type for integration runtime
     sharing.Constant filled by server.
    :type authorization_type: str
    :param resource_id: Required. The resource identifier of the integration runtime to be shared.
    :type resource_id: str
    """

    _validation = {
        'authorization_type': {'required': True},
        'resource_id': {'required': True},
    }

    _attribute_map = {
        'authorization_type': {'key': 'authorizationType', 'type': 'str'},
        'resource_id': {'key': 'resourceId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(LinkedIntegrationRuntimeRbacAuthorization, self).__init__(**kwargs)
        self.authorization_type = 'RBAC'  # type: str
        self.resource_id = kwargs['resource_id']


class LinkedIntegrationRuntimeRequest(msrest.serialization.Model):
    """Data factory name for linked integration runtime request.

    All required parameters must be populated in order to send to Azure.

    :param linked_factory_name: Required. The data factory name for linked integration runtime.
    :type linked_factory_name: str
    """

    _validation = {
        'linked_factory_name': {'required': True},
    }

    _attribute_map = {
        'linked_factory_name': {'key': 'factoryName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(LinkedIntegrationRuntimeRequest, self).__init__(**kwargs)
        self.linked_factory_name = kwargs['linked_factory_name']


class LinkedServiceReference(msrest.serialization.Model):
    """Linked service reference type.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. Linked service reference type. Default value: "LinkedServiceReference".
    :vartype type: str
    :param reference_name: Required. Reference LinkedService name.
    :type reference_name: str
    :param parameters: Arguments for LinkedService.
    :type parameters: dict[str, object]
    """

    _validation = {
        'type': {'required': True, 'constant': True},
        'reference_name': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'reference_name': {'key': 'referenceName', 'type': 'str'},
        'parameters': {'key': 'parameters', 'type': '{object}'},
    }

    type = "LinkedServiceReference"

    def __init__(
        self,
        **kwargs
    ):
        super(LinkedServiceReference, self).__init__(**kwargs)
        self.reference_name = kwargs['reference_name']
        self.parameters = kwargs.get('parameters', None)


class ManagedIntegrationRuntime(IntegrationRuntime):
    """Managed integration runtime, including managed elastic and managed dedicated integration runtimes.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param type: Required. Type of integration runtime.Constant filled by server.  Possible values
     include: "Managed", "SelfHosted".
    :type type: str or ~dfaz_management_client.models.IntegrationRuntimeType
    :param description: Integration runtime description.
    :type description: str
    :ivar state: Integration runtime state, only valid for managed dedicated integration runtime.
     Possible values include: "Initial", "Stopped", "Started", "Starting", "Stopping",
     "NeedRegistration", "Online", "Limited", "Offline", "AccessDenied".
    :vartype state: str or ~dfaz_management_client.models.IntegrationRuntimeState
    :param repo_configuration: Git repo information of the factory.
    :type repo_configuration: ~dfaz_management_client.models.FactoryRepoConfiguration
    :param fake_identity: This is only for az test.
    :type fake_identity: ~dfaz_management_client.models.FakeFactoryIdentity
    :param zones: This is only for az test.
    :type zones: list[str]
    :param compute_properties: The compute resource for managed integration runtime.
    :type compute_properties: ~dfaz_management_client.models.IntegrationRuntimeComputeProperties
    :param ssis_properties: SSIS properties for managed integration runtime.
    :type ssis_properties: ~dfaz_management_client.models.IntegrationRuntimeSsisProperties
    """

    _validation = {
        'type': {'required': True},
        'state': {'readonly': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'type': {'key': 'type', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'state': {'key': 'state', 'type': 'str'},
        'repo_configuration': {'key': 'repoConfiguration', 'type': 'FactoryRepoConfiguration'},
        'fake_identity': {'key': 'fakeIdentity', 'type': 'FakeFactoryIdentity'},
        'zones': {'key': 'zones', 'type': '[str]'},
        'compute_properties': {'key': 'typeProperties.computeProperties', 'type': 'IntegrationRuntimeComputeProperties'},
        'ssis_properties': {'key': 'typeProperties.ssisProperties', 'type': 'IntegrationRuntimeSsisProperties'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ManagedIntegrationRuntime, self).__init__(**kwargs)
        self.type = 'Managed'  # type: str
        self.state = None
        self.repo_configuration = kwargs.get('repo_configuration', None)
        self.fake_identity = kwargs.get('fake_identity', None)
        self.zones = kwargs.get('zones', None)
        self.compute_properties = kwargs.get('compute_properties', None)
        self.ssis_properties = kwargs.get('ssis_properties', None)


class ManagedIntegrationRuntimeError(msrest.serialization.Model):
    """Error definition for managed integration runtime.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :ivar time: The time when the error occurred.
    :vartype time: ~datetime.datetime
    :ivar code: Error code.
    :vartype code: str
    :ivar parameters: Managed integration runtime error parameters.
    :vartype parameters: list[str]
    :ivar message: Error message.
    :vartype message: str
    """

    _validation = {
        'time': {'readonly': True},
        'code': {'readonly': True},
        'parameters': {'readonly': True},
        'message': {'readonly': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'time': {'key': 'time', 'type': 'iso-8601'},
        'code': {'key': 'code', 'type': 'str'},
        'parameters': {'key': 'parameters', 'type': '[str]'},
        'message': {'key': 'message', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ManagedIntegrationRuntimeError, self).__init__(**kwargs)
        self.additional_properties = kwargs.get('additional_properties', None)
        self.time = None
        self.code = None
        self.parameters = None
        self.message = None


class ManagedIntegrationRuntimeNode(msrest.serialization.Model):
    """Properties of integration runtime node.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :ivar node_id: The managed integration runtime node id.
    :vartype node_id: str
    :ivar status: The managed integration runtime node status. Possible values include: "Starting",
     "Available", "Recycling", "Unavailable".
    :vartype status: str or ~dfaz_management_client.models.ManagedIntegrationRuntimeNodeStatus
    :param errors: The errors that occurred on this integration runtime node.
    :type errors: list[~dfaz_management_client.models.ManagedIntegrationRuntimeError]
    """

    _validation = {
        'node_id': {'readonly': True},
        'status': {'readonly': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'node_id': {'key': 'nodeId', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'errors': {'key': 'errors', 'type': '[ManagedIntegrationRuntimeError]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ManagedIntegrationRuntimeNode, self).__init__(**kwargs)
        self.additional_properties = kwargs.get('additional_properties', None)
        self.node_id = None
        self.status = None
        self.errors = kwargs.get('errors', None)


class ManagedIntegrationRuntimeOperationResult(msrest.serialization.Model):
    """Properties of managed integration runtime operation result.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :ivar type: The operation type. Could be start or stop.
    :vartype type: str
    :ivar start_time: The start time of the operation.
    :vartype start_time: ~datetime.datetime
    :ivar result: The operation result.
    :vartype result: str
    :ivar error_code: The error code.
    :vartype error_code: str
    :ivar parameters: Managed integration runtime error parameters.
    :vartype parameters: list[str]
    :ivar activity_id: The activity id for the operation request.
    :vartype activity_id: str
    """

    _validation = {
        'type': {'readonly': True},
        'start_time': {'readonly': True},
        'result': {'readonly': True},
        'error_code': {'readonly': True},
        'parameters': {'readonly': True},
        'activity_id': {'readonly': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'type': {'key': 'type', 'type': 'str'},
        'start_time': {'key': 'startTime', 'type': 'iso-8601'},
        'result': {'key': 'result', 'type': 'str'},
        'error_code': {'key': 'errorCode', 'type': 'str'},
        'parameters': {'key': 'parameters', 'type': '[str]'},
        'activity_id': {'key': 'activityId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ManagedIntegrationRuntimeOperationResult, self).__init__(**kwargs)
        self.additional_properties = kwargs.get('additional_properties', None)
        self.type = None
        self.start_time = None
        self.result = None
        self.error_code = None
        self.parameters = None
        self.activity_id = None


class ManagedIntegrationRuntimeStatus(IntegrationRuntimeStatus):
    """Managed integration runtime status.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param type: Required. Type of integration runtime.Constant filled by server.  Possible values
     include: "Managed", "SelfHosted".
    :type type: str or ~dfaz_management_client.models.IntegrationRuntimeType
    :ivar data_factory_name: The data factory name which the integration runtime belong to.
    :vartype data_factory_name: str
    :ivar state: The state of integration runtime. Possible values include: "Initial", "Stopped",
     "Started", "Starting", "Stopping", "NeedRegistration", "Online", "Limited", "Offline",
     "AccessDenied".
    :vartype state: str or ~dfaz_management_client.models.IntegrationRuntimeState
    :ivar create_time: The time at which the integration runtime was created, in ISO8601 format.
    :vartype create_time: ~datetime.datetime
    :ivar nodes: The list of nodes for managed integration runtime.
    :vartype nodes: list[~dfaz_management_client.models.ManagedIntegrationRuntimeNode]
    :ivar other_errors: The errors that occurred on this integration runtime.
    :vartype other_errors: list[~dfaz_management_client.models.ManagedIntegrationRuntimeError]
    :ivar last_operation: The last operation result that occurred on this integration runtime.
    :vartype last_operation:
     ~dfaz_management_client.models.ManagedIntegrationRuntimeOperationResult
    """

    _validation = {
        'type': {'required': True},
        'data_factory_name': {'readonly': True},
        'state': {'readonly': True},
        'create_time': {'readonly': True},
        'nodes': {'readonly': True},
        'other_errors': {'readonly': True},
        'last_operation': {'readonly': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'type': {'key': 'type', 'type': 'str'},
        'data_factory_name': {'key': 'dataFactoryName', 'type': 'str'},
        'state': {'key': 'state', 'type': 'str'},
        'create_time': {'key': 'typeProperties.createTime', 'type': 'iso-8601'},
        'nodes': {'key': 'typeProperties.nodes', 'type': '[ManagedIntegrationRuntimeNode]'},
        'other_errors': {'key': 'typeProperties.otherErrors', 'type': '[ManagedIntegrationRuntimeError]'},
        'last_operation': {'key': 'typeProperties.lastOperation', 'type': 'ManagedIntegrationRuntimeOperationResult'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ManagedIntegrationRuntimeStatus, self).__init__(**kwargs)
        self.type = 'Managed'  # type: str
        self.create_time = None
        self.nodes = None
        self.other_errors = None
        self.last_operation = None


class PackageStore(msrest.serialization.Model):
    """Package store for the SSIS integration runtime.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The name of the package store.
    :type name: str
    :param package_store_linked_service: Required. The package store linked service reference.
    :type package_store_linked_service: ~dfaz_management_client.models.EntityReference
    """

    _validation = {
        'name': {'required': True},
        'package_store_linked_service': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'package_store_linked_service': {'key': 'packageStoreLinkedService', 'type': 'EntityReference'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(PackageStore, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.package_store_linked_service = kwargs['package_store_linked_service']


class PipelineReference(msrest.serialization.Model):
    """Pipeline reference type.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. Pipeline reference type. Default value: "PipelineReference".
    :vartype type: str
    :param reference_name: Required. Reference pipeline name.
    :type reference_name: str
    :param name: Reference name.
    :type name: str
    """

    _validation = {
        'type': {'required': True, 'constant': True},
        'reference_name': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'reference_name': {'key': 'referenceName', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
    }

    type = "PipelineReference"

    def __init__(
        self,
        **kwargs
    ):
        super(PipelineReference, self).__init__(**kwargs)
        self.reference_name = kwargs['reference_name']
        self.name = kwargs.get('name', None)


class RecurrenceSchedule(msrest.serialization.Model):
    """The recurrence schedule.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param minutes: The minutes.
    :type minutes: list[int]
    :param hours: The hours.
    :type hours: list[int]
    :param week_days: The days of the week.
    :type week_days: list[str or ~dfaz_management_client.models.DaysOfWeek]
    :param month_days: The month days.
    :type month_days: list[int]
    :param monthly_occurrences: The monthly occurrences.
    :type monthly_occurrences: list[~dfaz_management_client.models.RecurrenceScheduleOccurrence]
    """

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'minutes': {'key': 'minutes', 'type': '[int]'},
        'hours': {'key': 'hours', 'type': '[int]'},
        'week_days': {'key': 'weekDays', 'type': '[str]'},
        'month_days': {'key': 'monthDays', 'type': '[int]'},
        'monthly_occurrences': {'key': 'monthlyOccurrences', 'type': '[RecurrenceScheduleOccurrence]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RecurrenceSchedule, self).__init__(**kwargs)
        self.additional_properties = kwargs.get('additional_properties', None)
        self.minutes = kwargs.get('minutes', None)
        self.hours = kwargs.get('hours', None)
        self.week_days = kwargs.get('week_days', None)
        self.month_days = kwargs.get('month_days', None)
        self.monthly_occurrences = kwargs.get('monthly_occurrences', None)


class RecurrenceScheduleOccurrence(msrest.serialization.Model):
    """The recurrence schedule occurrence.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param day: The day of the week. Possible values include: "Sunday", "Monday", "Tuesday",
     "Wednesday", "Thursday", "Friday", "Saturday".
    :type day: str or ~dfaz_management_client.models.DayOfWeek
    :param occurrence: The occurrence.
    :type occurrence: int
    """

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'day': {'key': 'day', 'type': 'str'},
        'occurrence': {'key': 'occurrence', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RecurrenceScheduleOccurrence, self).__init__(**kwargs)
        self.additional_properties = kwargs.get('additional_properties', None)
        self.day = kwargs.get('day', None)
        self.occurrence = kwargs.get('occurrence', None)


class ReplicaSet(msrest.serialization.Model):
    """Replica Set Definition.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar replica_set_id: ReplicaSet Id.
    :vartype replica_set_id: str
    :param location: Virtual network location.
    :type location: str
    :ivar vnet_site_id: Virtual network site id.
    :vartype vnet_site_id: str
    :param subnet_id: The name of the virtual network that Domain Services will be deployed on. The
     id of the subnet that Domain Services will be deployed on.
     /virtualNetwork/vnetName/subnets/subnetName.
    :type subnet_id: str
    :ivar domain_controller_ip_address: List of Domain Controller IP Address.
    :vartype domain_controller_ip_address: list[str]
    :ivar external_access_ip_address: External access ip address.
    :vartype external_access_ip_address: str
    :ivar service_status: Status of Domain Service instance.
    :vartype service_status: str
    :ivar health_last_evaluated: Last domain evaluation run DateTime.
    :vartype health_last_evaluated: ~datetime.datetime
    :ivar health_monitors: List of Domain Health Monitors.
    :vartype health_monitors: list[~dfaz_management_client.models.HealthMonitor]
    :ivar health_alerts: List of Domain Health Alerts.
    :vartype health_alerts: list[~dfaz_management_client.models.HealthAlert]
    """

    _validation = {
        'replica_set_id': {'readonly': True},
        'vnet_site_id': {'readonly': True},
        'domain_controller_ip_address': {'readonly': True},
        'external_access_ip_address': {'readonly': True},
        'service_status': {'readonly': True},
        'health_last_evaluated': {'readonly': True},
        'health_monitors': {'readonly': True},
        'health_alerts': {'readonly': True},
    }

    _attribute_map = {
        'replica_set_id': {'key': 'replicaSetId', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'vnet_site_id': {'key': 'vnetSiteId', 'type': 'str'},
        'subnet_id': {'key': 'subnetId', 'type': 'str'},
        'domain_controller_ip_address': {'key': 'domainControllerIpAddress', 'type': '[str]'},
        'external_access_ip_address': {'key': 'externalAccessIpAddress', 'type': 'str'},
        'service_status': {'key': 'serviceStatus', 'type': 'str'},
        'health_last_evaluated': {'key': 'healthLastEvaluated', 'type': 'rfc-1123'},
        'health_monitors': {'key': 'healthMonitors', 'type': '[HealthMonitor]'},
        'health_alerts': {'key': 'healthAlerts', 'type': '[HealthAlert]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ReplicaSet, self).__init__(**kwargs)
        self.replica_set_id = None
        self.location = kwargs.get('location', None)
        self.vnet_site_id = None
        self.subnet_id = kwargs.get('subnet_id', None)
        self.domain_controller_ip_address = None
        self.external_access_ip_address = None
        self.service_status = None
        self.health_last_evaluated = None
        self.health_monitors = None
        self.health_alerts = None


class RerunTumblingWindowTrigger(Trigger):
    """Trigger that schedules pipeline reruns for all fixed time interval windows from a requested start time to requested end time.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param type: Required. Trigger type.Constant filled by server.
    :type type: str
    :param description: Trigger description.
    :type description: str
    :ivar runtime_state: Indicates if trigger is running or not. Updated when Start/Stop APIs are
     called on the Trigger. Possible values include: "Started", "Stopped", "Disabled".
    :vartype runtime_state: str or ~dfaz_management_client.models.TriggerRuntimeState
    :param annotations: List of tags that can be used for describing the trigger.
    :type annotations: list[object]
    :param parent_trigger: Required. The parent trigger reference.
    :type parent_trigger: object
    :param requested_start_time: Required. The start time for the time period for which restatement
     is initiated. Only UTC time is currently supported.
    :type requested_start_time: ~datetime.datetime
    :param requested_end_time: Required. The end time for the time period for which restatement is
     initiated. Only UTC time is currently supported.
    :type requested_end_time: ~datetime.datetime
    :param rerun_concurrency: Required. The max number of parallel time windows (ready for
     execution) for which a rerun is triggered.
    :type rerun_concurrency: int
    """

    _validation = {
        'type': {'required': True},
        'runtime_state': {'readonly': True},
        'parent_trigger': {'required': True},
        'requested_start_time': {'required': True},
        'requested_end_time': {'required': True},
        'rerun_concurrency': {'required': True, 'maximum': 50, 'minimum': 1},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'type': {'key': 'type', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'runtime_state': {'key': 'runtimeState', 'type': 'str'},
        'annotations': {'key': 'annotations', 'type': '[object]'},
        'parent_trigger': {'key': 'typeProperties.parentTrigger', 'type': 'object'},
        'requested_start_time': {'key': 'typeProperties.requestedStartTime', 'type': 'iso-8601'},
        'requested_end_time': {'key': 'typeProperties.requestedEndTime', 'type': 'iso-8601'},
        'rerun_concurrency': {'key': 'typeProperties.rerunConcurrency', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RerunTumblingWindowTrigger, self).__init__(**kwargs)
        self.type = 'RerunTumblingWindowTrigger'  # type: str
        self.parent_trigger = kwargs['parent_trigger']
        self.requested_start_time = kwargs['requested_start_time']
        self.requested_end_time = kwargs['requested_end_time']
        self.rerun_concurrency = kwargs['rerun_concurrency']


class RetryPolicy(msrest.serialization.Model):
    """Execution policy for an activity.

    :param count: Maximum ordinary retry attempts. Default is 0. Type: integer (or Expression with
     resultType integer), minimum: 0.
    :type count: object
    :param interval_in_seconds: Interval between retries in seconds. Default is 30.
    :type interval_in_seconds: int
    """

    _validation = {
        'interval_in_seconds': {'maximum': 86400, 'minimum': 30},
    }

    _attribute_map = {
        'count': {'key': 'count', 'type': 'object'},
        'interval_in_seconds': {'key': 'intervalInSeconds', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RetryPolicy, self).__init__(**kwargs)
        self.count = kwargs.get('count', None)
        self.interval_in_seconds = kwargs.get('interval_in_seconds', None)


class ScheduleTrigger(MultiplePipelineTrigger):
    """Trigger that creates pipeline runs periodically, on schedule.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param type: Required. Trigger type.Constant filled by server.
    :type type: str
    :param description: Trigger description.
    :type description: str
    :ivar runtime_state: Indicates if trigger is running or not. Updated when Start/Stop APIs are
     called on the Trigger. Possible values include: "Started", "Stopped", "Disabled".
    :vartype runtime_state: str or ~dfaz_management_client.models.TriggerRuntimeState
    :param annotations: List of tags that can be used for describing the trigger.
    :type annotations: list[object]
    :param pipelines: Pipelines that need to be started.
    :type pipelines: list[~dfaz_management_client.models.TriggerPipelineReference]
    :param recurrence: Required. Recurrence schedule configuration.
    :type recurrence: ~dfaz_management_client.models.ScheduleTriggerRecurrence
    """

    _validation = {
        'type': {'required': True},
        'runtime_state': {'readonly': True},
        'recurrence': {'required': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'type': {'key': 'type', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'runtime_state': {'key': 'runtimeState', 'type': 'str'},
        'annotations': {'key': 'annotations', 'type': '[object]'},
        'pipelines': {'key': 'pipelines', 'type': '[TriggerPipelineReference]'},
        'recurrence': {'key': 'typeProperties.recurrence', 'type': 'ScheduleTriggerRecurrence'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ScheduleTrigger, self).__init__(**kwargs)
        self.type = 'ScheduleTrigger'  # type: str
        self.recurrence = kwargs['recurrence']


class ScheduleTriggerRecurrence(msrest.serialization.Model):
    """The workflow trigger recurrence.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param frequency: The frequency. Possible values include: "NotSpecified", "Minute", "Hour",
     "Day", "Week", "Month", "Year".
    :type frequency: str or ~dfaz_management_client.models.RecurrenceFrequency
    :param interval: The interval.
    :type interval: int
    :param start_time: The start time.
    :type start_time: ~datetime.datetime
    :param end_time: The end time.
    :type end_time: ~datetime.datetime
    :param time_zone: The time zone.
    :type time_zone: str
    :param schedule: The recurrence schedule.
    :type schedule: ~dfaz_management_client.models.RecurrenceSchedule
    """

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'frequency': {'key': 'frequency', 'type': 'str'},
        'interval': {'key': 'interval', 'type': 'int'},
        'start_time': {'key': 'startTime', 'type': 'iso-8601'},
        'end_time': {'key': 'endTime', 'type': 'iso-8601'},
        'time_zone': {'key': 'timeZone', 'type': 'str'},
        'schedule': {'key': 'schedule', 'type': 'RecurrenceSchedule'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ScheduleTriggerRecurrence, self).__init__(**kwargs)
        self.additional_properties = kwargs.get('additional_properties', None)
        self.frequency = kwargs.get('frequency', None)
        self.interval = kwargs.get('interval', None)
        self.start_time = kwargs.get('start_time', None)
        self.end_time = kwargs.get('end_time', None)
        self.time_zone = kwargs.get('time_zone', None)
        self.schedule = kwargs.get('schedule', None)


class SecretBase(msrest.serialization.Model):
    """The base definition of a secret type.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: SecureString.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Type of the secret.Constant filled by server.
    :type type: str
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
    }

    _subtype_map = {
        'type': {'SecureString': 'SecureString'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SecretBase, self).__init__(**kwargs)
        self.type = None  # type: Optional[str]


class SecureString(SecretBase):
    """Azure Data Factory secure string definition. The string value will be masked with asterisks '*' during Get or List API calls.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Type of the secret.Constant filled by server.
    :type type: str
    :param value: Required. Value of secure string.
    :type value: str
    """

    _validation = {
        'type': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SecureString, self).__init__(**kwargs)
        self.type = 'SecureString'  # type: str
        self.value = kwargs['value']


class SelfDependencyTumblingWindowTriggerReference(DependencyReference):
    """Self referenced tumbling window trigger dependency.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. The type of dependency reference.Constant filled by server.
    :type type: str
    :param offset: Required. Timespan applied to the start time of a tumbling window when
     evaluating dependency.
    :type offset: str
    :param size: The size of the window when evaluating the dependency. If undefined the frequency
     of the tumbling window will be used.
    :type size: str
    """

    _validation = {
        'type': {'required': True},
        'offset': {'required': True, 'max_length': 15, 'min_length': 8, 'pattern': r'-((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9]))'},
        'size': {'max_length': 15, 'min_length': 8, 'pattern': r'((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9]))'},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'offset': {'key': 'offset', 'type': 'str'},
        'size': {'key': 'size', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SelfDependencyTumblingWindowTriggerReference, self).__init__(**kwargs)
        self.type = 'SelfDependencyTumblingWindowTriggerReference'  # type: str
        self.offset = kwargs['offset']
        self.size = kwargs.get('size', None)


class SelfHostedIntegrationRuntime(IntegrationRuntime):
    """Self-hosted integration runtime.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param type: Required. Type of integration runtime.Constant filled by server.  Possible values
     include: "Managed", "SelfHosted".
    :type type: str or ~dfaz_management_client.models.IntegrationRuntimeType
    :param description: Integration runtime description.
    :type description: str
    :param linked_info: The base definition of a linked integration runtime.
    :type linked_info: ~dfaz_management_client.models.LinkedIntegrationRuntimeType
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'type': {'key': 'type', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'linked_info': {'key': 'typeProperties.linkedInfo', 'type': 'LinkedIntegrationRuntimeType'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SelfHostedIntegrationRuntime, self).__init__(**kwargs)
        self.type = 'SelfHosted'  # type: str
        self.linked_info = kwargs.get('linked_info', None)


class SelfHostedIntegrationRuntimeNode(msrest.serialization.Model):
    """Properties of Self-hosted integration runtime node.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :ivar node_name: Name of the integration runtime node.
    :vartype node_name: str
    :ivar machine_name: Machine name of the integration runtime node.
    :vartype machine_name: str
    :ivar host_service_uri: URI for the host machine of the integration runtime.
    :vartype host_service_uri: str
    :ivar status: Status of the integration runtime node. Possible values include:
     "NeedRegistration", "Online", "Limited", "Offline", "Upgrading", "Initializing",
     "InitializeFailed".
    :vartype status: str or ~dfaz_management_client.models.SelfHostedIntegrationRuntimeNodeStatus
    :ivar capabilities: The integration runtime capabilities dictionary.
    :vartype capabilities: dict[str, str]
    :ivar version_status: Status of the integration runtime node version.
    :vartype version_status: str
    :ivar version: Version of the integration runtime node.
    :vartype version: str
    :ivar register_time: The time at which the integration runtime node was registered in ISO8601
     format.
    :vartype register_time: ~datetime.datetime
    :ivar last_connect_time: The most recent time at which the integration runtime was connected in
     ISO8601 format.
    :vartype last_connect_time: ~datetime.datetime
    :ivar expiry_time: The time at which the integration runtime will expire in ISO8601 format.
    :vartype expiry_time: ~datetime.datetime
    :ivar last_start_time: The time the node last started up.
    :vartype last_start_time: ~datetime.datetime
    :ivar last_stop_time: The integration runtime node last stop time.
    :vartype last_stop_time: ~datetime.datetime
    :ivar last_update_result: The result of the last integration runtime node update. Possible
     values include: "None", "Succeed", "Fail".
    :vartype last_update_result: str or
     ~dfaz_management_client.models.IntegrationRuntimeUpdateResult
    :ivar last_start_update_time: The last time for the integration runtime node update start.
    :vartype last_start_update_time: ~datetime.datetime
    :ivar last_end_update_time: The last time for the integration runtime node update end.
    :vartype last_end_update_time: ~datetime.datetime
    :ivar is_active_dispatcher: Indicates whether this node is the active dispatcher for
     integration runtime requests.
    :vartype is_active_dispatcher: bool
    :ivar concurrent_jobs_limit: Maximum concurrent jobs on the integration runtime node.
    :vartype concurrent_jobs_limit: int
    :ivar max_concurrent_jobs: The maximum concurrent jobs in this integration runtime.
    :vartype max_concurrent_jobs: int
    """

    _validation = {
        'node_name': {'readonly': True},
        'machine_name': {'readonly': True},
        'host_service_uri': {'readonly': True},
        'status': {'readonly': True},
        'capabilities': {'readonly': True},
        'version_status': {'readonly': True},
        'version': {'readonly': True},
        'register_time': {'readonly': True},
        'last_connect_time': {'readonly': True},
        'expiry_time': {'readonly': True},
        'last_start_time': {'readonly': True},
        'last_stop_time': {'readonly': True},
        'last_update_result': {'readonly': True},
        'last_start_update_time': {'readonly': True},
        'last_end_update_time': {'readonly': True},
        'is_active_dispatcher': {'readonly': True},
        'concurrent_jobs_limit': {'readonly': True},
        'max_concurrent_jobs': {'readonly': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'node_name': {'key': 'nodeName', 'type': 'str'},
        'machine_name': {'key': 'machineName', 'type': 'str'},
        'host_service_uri': {'key': 'hostServiceUri', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'capabilities': {'key': 'capabilities', 'type': '{str}'},
        'version_status': {'key': 'versionStatus', 'type': 'str'},
        'version': {'key': 'version', 'type': 'str'},
        'register_time': {'key': 'registerTime', 'type': 'iso-8601'},
        'last_connect_time': {'key': 'lastConnectTime', 'type': 'iso-8601'},
        'expiry_time': {'key': 'expiryTime', 'type': 'iso-8601'},
        'last_start_time': {'key': 'lastStartTime', 'type': 'iso-8601'},
        'last_stop_time': {'key': 'lastStopTime', 'type': 'iso-8601'},
        'last_update_result': {'key': 'lastUpdateResult', 'type': 'str'},
        'last_start_update_time': {'key': 'lastStartUpdateTime', 'type': 'iso-8601'},
        'last_end_update_time': {'key': 'lastEndUpdateTime', 'type': 'iso-8601'},
        'is_active_dispatcher': {'key': 'isActiveDispatcher', 'type': 'bool'},
        'concurrent_jobs_limit': {'key': 'concurrentJobsLimit', 'type': 'int'},
        'max_concurrent_jobs': {'key': 'maxConcurrentJobs', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SelfHostedIntegrationRuntimeNode, self).__init__(**kwargs)
        self.additional_properties = kwargs.get('additional_properties', None)
        self.node_name = None
        self.machine_name = None
        self.host_service_uri = None
        self.status = None
        self.capabilities = None
        self.version_status = None
        self.version = None
        self.register_time = None
        self.last_connect_time = None
        self.expiry_time = None
        self.last_start_time = None
        self.last_stop_time = None
        self.last_update_result = None
        self.last_start_update_time = None
        self.last_end_update_time = None
        self.is_active_dispatcher = None
        self.concurrent_jobs_limit = None
        self.max_concurrent_jobs = None


class SelfHostedIntegrationRuntimeStatus(IntegrationRuntimeStatus):
    """Self-hosted integration runtime status.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param type: Required. Type of integration runtime.Constant filled by server.  Possible values
     include: "Managed", "SelfHosted".
    :type type: str or ~dfaz_management_client.models.IntegrationRuntimeType
    :ivar data_factory_name: The data factory name which the integration runtime belong to.
    :vartype data_factory_name: str
    :ivar state: The state of integration runtime. Possible values include: "Initial", "Stopped",
     "Started", "Starting", "Stopping", "NeedRegistration", "Online", "Limited", "Offline",
     "AccessDenied".
    :vartype state: str or ~dfaz_management_client.models.IntegrationRuntimeState
    :ivar create_time: The time at which the integration runtime was created, in ISO8601 format.
    :vartype create_time: ~datetime.datetime
    :ivar task_queue_id: The task queue id of the integration runtime.
    :vartype task_queue_id: str
    :ivar internal_channel_encryption: It is used to set the encryption mode for node-node
     communication channel (when more than 2 self-hosted integration runtime nodes exist). Possible
     values include: "NotSet", "SslEncrypted", "NotEncrypted".
    :vartype internal_channel_encryption: str or
     ~dfaz_management_client.models.IntegrationRuntimeInternalChannelEncryptionMode
    :ivar version: Version of the integration runtime.
    :vartype version: str
    :param nodes: The list of nodes for this integration runtime.
    :type nodes: list[~dfaz_management_client.models.SelfHostedIntegrationRuntimeNode]
    :ivar scheduled_update_date: The date at which the integration runtime will be scheduled to
     update, in ISO8601 format.
    :vartype scheduled_update_date: ~datetime.datetime
    :ivar update_delay_offset: The time in the date scheduled by service to update the integration
     runtime, e.g., PT03H is 3 hours.
    :vartype update_delay_offset: str
    :ivar local_time_zone_offset: The local time zone offset in hours.
    :vartype local_time_zone_offset: str
    :ivar capabilities: Object with additional information about integration runtime capabilities.
    :vartype capabilities: dict[str, str]
    :ivar service_urls: The URLs for the services used in integration runtime backend service.
    :vartype service_urls: list[str]
    :ivar auto_update: Whether Self-hosted integration runtime auto update has been turned on.
     Possible values include: "On", "Off", "fakeValue1", "fakeValue2", "fakeValue3", "fakeValue4",
     "fakeValue5", "fakeValue6".
    :vartype auto_update: str or ~dfaz_management_client.models.IntegrationRuntimeAutoUpdate
    :ivar version_status: Status of the integration runtime version.
    :vartype version_status: str
    :param links: The list of linked integration runtimes that are created to share with this
     integration runtime.
    :type links: list[~dfaz_management_client.models.LinkedIntegrationRuntime]
    :ivar pushed_version: The version that the integration runtime is going to update to.
    :vartype pushed_version: str
    :ivar latest_version: The latest version on download center.
    :vartype latest_version: str
    :ivar auto_update_eta: The estimated time when the self-hosted integration runtime will be
     updated.
    :vartype auto_update_eta: ~datetime.datetime
    """

    _validation = {
        'type': {'required': True},
        'data_factory_name': {'readonly': True},
        'state': {'readonly': True},
        'create_time': {'readonly': True},
        'task_queue_id': {'readonly': True},
        'internal_channel_encryption': {'readonly': True},
        'version': {'readonly': True},
        'scheduled_update_date': {'readonly': True},
        'update_delay_offset': {'readonly': True},
        'local_time_zone_offset': {'readonly': True},
        'capabilities': {'readonly': True},
        'service_urls': {'readonly': True},
        'auto_update': {'readonly': True},
        'version_status': {'readonly': True},
        'pushed_version': {'readonly': True},
        'latest_version': {'readonly': True},
        'auto_update_eta': {'readonly': True},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'type': {'key': 'type', 'type': 'str'},
        'data_factory_name': {'key': 'dataFactoryName', 'type': 'str'},
        'state': {'key': 'state', 'type': 'str'},
        'create_time': {'key': 'typeProperties.createTime', 'type': 'iso-8601'},
        'task_queue_id': {'key': 'typeProperties.taskQueueId', 'type': 'str'},
        'internal_channel_encryption': {'key': 'typeProperties.internalChannelEncryption', 'type': 'str'},
        'version': {'key': 'typeProperties.version', 'type': 'str'},
        'nodes': {'key': 'typeProperties.nodes', 'type': '[SelfHostedIntegrationRuntimeNode]'},
        'scheduled_update_date': {'key': 'typeProperties.scheduledUpdateDate', 'type': 'iso-8601'},
        'update_delay_offset': {'key': 'typeProperties.updateDelayOffset', 'type': 'str'},
        'local_time_zone_offset': {'key': 'typeProperties.localTimeZoneOffset', 'type': 'str'},
        'capabilities': {'key': 'typeProperties.capabilities', 'type': '{str}'},
        'service_urls': {'key': 'typeProperties.serviceUrls', 'type': '[str]'},
        'auto_update': {'key': 'typeProperties.autoUpdate', 'type': 'str'},
        'version_status': {'key': 'typeProperties.versionStatus', 'type': 'str'},
        'links': {'key': 'typeProperties.links', 'type': '[LinkedIntegrationRuntime]'},
        'pushed_version': {'key': 'typeProperties.pushedVersion', 'type': 'str'},
        'latest_version': {'key': 'typeProperties.latestVersion', 'type': 'str'},
        'auto_update_eta': {'key': 'typeProperties.autoUpdateETA', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SelfHostedIntegrationRuntimeStatus, self).__init__(**kwargs)
        self.type = 'SelfHosted'  # type: str
        self.create_time = None
        self.task_queue_id = None
        self.internal_channel_encryption = None
        self.version = None
        self.nodes = kwargs.get('nodes', None)
        self.scheduled_update_date = None
        self.update_delay_offset = None
        self.local_time_zone_offset = None
        self.capabilities = None
        self.service_urls = None
        self.auto_update = None
        self.version_status = None
        self.links = kwargs.get('links', None)
        self.pushed_version = None
        self.latest_version = None
        self.auto_update_eta = None


class SsisObjectMetadata(msrest.serialization.Model):
    """SSIS object metadata.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: SsisEnvironment, SsisFolder, SsisPackage, SsisProject.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Type of metadata.Constant filled by server.  Possible values include:
     "Folder", "Project", "Package", "Environment".
    :type type: str or ~dfaz_management_client.models.SsisObjectMetadataType
    :param id: Metadata id.
    :type id: long
    :param name: Metadata name.
    :type name: str
    :param description: Metadata description.
    :type description: str
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'id': {'key': 'id', 'type': 'long'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    _subtype_map = {
        'type': {'Environment': 'SsisEnvironment', 'Folder': 'SsisFolder', 'Package': 'SsisPackage', 'Project': 'SsisProject'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SsisObjectMetadata, self).__init__(**kwargs)
        self.type = None  # type: Optional[str]
        self.id = kwargs.get('id', None)
        self.name = kwargs.get('name', None)
        self.description = kwargs.get('description', None)


class SsisEnvironment(SsisObjectMetadata):
    """Ssis environment.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Type of metadata.Constant filled by server.  Possible values include:
     "Folder", "Project", "Package", "Environment".
    :type type: str or ~dfaz_management_client.models.SsisObjectMetadataType
    :param id: Metadata id.
    :type id: long
    :param name: Metadata name.
    :type name: str
    :param description: Metadata description.
    :type description: str
    :param folder_id: Folder id which contains environment.
    :type folder_id: long
    :param variables: Variable in environment.
    :type variables: list[~dfaz_management_client.models.SsisVariable]
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'id': {'key': 'id', 'type': 'long'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'folder_id': {'key': 'folderId', 'type': 'long'},
        'variables': {'key': 'variables', 'type': '[SsisVariable]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SsisEnvironment, self).__init__(**kwargs)
        self.type = 'Environment'  # type: str
        self.folder_id = kwargs.get('folder_id', None)
        self.variables = kwargs.get('variables', None)


class SsisEnvironmentReference(msrest.serialization.Model):
    """Ssis environment reference.

    :param id: Environment reference id.
    :type id: long
    :param environment_folder_name: Environment folder name.
    :type environment_folder_name: str
    :param environment_name: Environment name.
    :type environment_name: str
    :param reference_type: Reference type.
    :type reference_type: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'long'},
        'environment_folder_name': {'key': 'environmentFolderName', 'type': 'str'},
        'environment_name': {'key': 'environmentName', 'type': 'str'},
        'reference_type': {'key': 'referenceType', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SsisEnvironmentReference, self).__init__(**kwargs)
        self.id = kwargs.get('id', None)
        self.environment_folder_name = kwargs.get('environment_folder_name', None)
        self.environment_name = kwargs.get('environment_name', None)
        self.reference_type = kwargs.get('reference_type', None)


class SsisFolder(SsisObjectMetadata):
    """Ssis folder.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Type of metadata.Constant filled by server.  Possible values include:
     "Folder", "Project", "Package", "Environment".
    :type type: str or ~dfaz_management_client.models.SsisObjectMetadataType
    :param id: Metadata id.
    :type id: long
    :param name: Metadata name.
    :type name: str
    :param description: Metadata description.
    :type description: str
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'id': {'key': 'id', 'type': 'long'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SsisFolder, self).__init__(**kwargs)
        self.type = 'Folder'  # type: str


class SsisObjectMetadataListResponse(msrest.serialization.Model):
    """A list of SSIS object metadata.

    :param value: List of SSIS object metadata.
    :type value: list[~dfaz_management_client.models.SsisObjectMetadata]
    :param next_link: The link to the next page of results, if any remaining results exist.
    :type next_link: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': '[SsisObjectMetadata]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SsisObjectMetadataListResponse, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)
        self.next_link = kwargs.get('next_link', None)


class SsisPackage(SsisObjectMetadata):
    """Ssis Package.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Type of metadata.Constant filled by server.  Possible values include:
     "Folder", "Project", "Package", "Environment".
    :type type: str or ~dfaz_management_client.models.SsisObjectMetadataType
    :param id: Metadata id.
    :type id: long
    :param name: Metadata name.
    :type name: str
    :param description: Metadata description.
    :type description: str
    :param folder_id: Folder id which contains package.
    :type folder_id: long
    :param project_version: Project version which contains package.
    :type project_version: long
    :param project_id: Project id which contains package.
    :type project_id: long
    :param parameters: Parameters in package.
    :type parameters: list[~dfaz_management_client.models.SsisParameter]
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'id': {'key': 'id', 'type': 'long'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'folder_id': {'key': 'folderId', 'type': 'long'},
        'project_version': {'key': 'projectVersion', 'type': 'long'},
        'project_id': {'key': 'projectId', 'type': 'long'},
        'parameters': {'key': 'parameters', 'type': '[SsisParameter]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SsisPackage, self).__init__(**kwargs)
        self.type = 'Package'  # type: str
        self.folder_id = kwargs.get('folder_id', None)
        self.project_version = kwargs.get('project_version', None)
        self.project_id = kwargs.get('project_id', None)
        self.parameters = kwargs.get('parameters', None)


class SsisParameter(msrest.serialization.Model):
    """Ssis parameter.

    :param id: Parameter id.
    :type id: long
    :param name: Parameter name.
    :type name: str
    :param description: Parameter description.
    :type description: str
    :param data_type: Parameter type.
    :type data_type: str
    :param required: Whether parameter is required.
    :type required: bool
    :param sensitive: Whether parameter is sensitive.
    :type sensitive: bool
    :param design_default_value: Design default value of parameter.
    :type design_default_value: str
    :param default_value: Default value of parameter.
    :type default_value: str
    :param sensitive_default_value: Default sensitive value of parameter.
    :type sensitive_default_value: str
    :param value_type: Parameter value type.
    :type value_type: str
    :param value_set: Parameter value set.
    :type value_set: bool
    :param variable: Parameter reference variable.
    :type variable: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'long'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'data_type': {'key': 'dataType', 'type': 'str'},
        'required': {'key': 'required', 'type': 'bool'},
        'sensitive': {'key': 'sensitive', 'type': 'bool'},
        'design_default_value': {'key': 'designDefaultValue', 'type': 'str'},
        'default_value': {'key': 'defaultValue', 'type': 'str'},
        'sensitive_default_value': {'key': 'sensitiveDefaultValue', 'type': 'str'},
        'value_type': {'key': 'valueType', 'type': 'str'},
        'value_set': {'key': 'valueSet', 'type': 'bool'},
        'variable': {'key': 'variable', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SsisParameter, self).__init__(**kwargs)
        self.id = kwargs.get('id', None)
        self.name = kwargs.get('name', None)
        self.description = kwargs.get('description', None)
        self.data_type = kwargs.get('data_type', None)
        self.required = kwargs.get('required', None)
        self.sensitive = kwargs.get('sensitive', None)
        self.design_default_value = kwargs.get('design_default_value', None)
        self.default_value = kwargs.get('default_value', None)
        self.sensitive_default_value = kwargs.get('sensitive_default_value', None)
        self.value_type = kwargs.get('value_type', None)
        self.value_set = kwargs.get('value_set', None)
        self.variable = kwargs.get('variable', None)


class SsisProject(SsisObjectMetadata):
    """Ssis project.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Type of metadata.Constant filled by server.  Possible values include:
     "Folder", "Project", "Package", "Environment".
    :type type: str or ~dfaz_management_client.models.SsisObjectMetadataType
    :param id: Metadata id.
    :type id: long
    :param name: Metadata name.
    :type name: str
    :param description: Metadata description.
    :type description: str
    :param folder_id: Folder id which contains project.
    :type folder_id: long
    :param version: Project version.
    :type version: long
    :param environment_refs: Environment reference in project.
    :type environment_refs: list[~dfaz_management_client.models.SsisEnvironmentReference]
    :param parameters: Parameters in project.
    :type parameters: list[~dfaz_management_client.models.SsisParameter]
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'id': {'key': 'id', 'type': 'long'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'folder_id': {'key': 'folderId', 'type': 'long'},
        'version': {'key': 'version', 'type': 'long'},
        'environment_refs': {'key': 'environmentRefs', 'type': '[SsisEnvironmentReference]'},
        'parameters': {'key': 'parameters', 'type': '[SsisParameter]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SsisProject, self).__init__(**kwargs)
        self.type = 'Project'  # type: str
        self.folder_id = kwargs.get('folder_id', None)
        self.version = kwargs.get('version', None)
        self.environment_refs = kwargs.get('environment_refs', None)
        self.parameters = kwargs.get('parameters', None)


class SsisVariable(msrest.serialization.Model):
    """Ssis variable.

    :param id: Variable id.
    :type id: long
    :param name: Variable name.
    :type name: str
    :param description: Variable description.
    :type description: str
    :param data_type: Variable type.
    :type data_type: str
    :param sensitive: Whether variable is sensitive.
    :type sensitive: bool
    :param value: Variable value.
    :type value: str
    :param sensitive_value: Variable sensitive value.
    :type sensitive_value: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'long'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'data_type': {'key': 'dataType', 'type': 'str'},
        'sensitive': {'key': 'sensitive', 'type': 'bool'},
        'value': {'key': 'value', 'type': 'str'},
        'sensitive_value': {'key': 'sensitiveValue', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SsisVariable, self).__init__(**kwargs)
        self.id = kwargs.get('id', None)
        self.name = kwargs.get('name', None)
        self.description = kwargs.get('description', None)
        self.data_type = kwargs.get('data_type', None)
        self.sensitive = kwargs.get('sensitive', None)
        self.value = kwargs.get('value', None)
        self.sensitive_value = kwargs.get('sensitive_value', None)


class TestJob(AutomlJob):
    """Automl Job definition.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param job_type: Required. Specifies the type of job.Constant filled by server.  Possible
     values include: "Command", "Sweep", "Labeling", "Pipeline", "Data", "AutoML".
    :type job_type: str or ~dfaz_management_client.models.JobType
    :ivar interaction_endpoints: Dictonary of endpoint URIs, keyed by enumerated JobEndpoints, can
     be added, removed or updated.
    :vartype interaction_endpoints: ~dfaz_management_client.models.JobBaseInteractionEndpoints
    :param description: The asset description text.
    :type description: str
    :param tags: A set of tags. Tag dictionary. Tags can be added, removed, and updated.
    :type tags: dict[str, str]
    :param experiment_name: The name of the experiment the job belongs to. If not set, the job is
     placed in the "Default" experiment.
    :type experiment_name: str
    :param compute_binding: Required. computeBinding of the job.
    :type compute_binding: str
    :param status: Status of the job. Possible values include: "NotStarted", "Starting",
     "Provisioning", "Preparing", "Queued", "Running", "Finalizing", "CancelRequested", "Completed",
     "Failed", "Canceled", "NotResponding", "Paused".
    :type status: str or ~dfaz_management_client.models.JobStatus
    :param max_run_duration_seconds: The max run duration in seconds, ater which the job will be
     cancelled.
    :type max_run_duration_seconds: long
    :param code_configuration: Required. Code Configuration of the job.
    :type code_configuration: str
    :param environment_id: Environment specification of the job.
    :type environment_id: str
    :param data_bindings: Mapping of data bindings used in the job.
    :type data_bindings: object
    :param distribution_configuration: Distributon configuration of the job. This should be one of
     MpiConfiguration, TensorflowConfiguration, or PyTorchConfiguration.
    :type distribution_configuration: object
    :param run_type: Run type.
    :type run_type: str
    :param run_source: Run source would be used by services calling AutoML CreateParentRun,
     if none is provided it would default to "AutoML"
     This value would be used for RootAttribution.
    :type run_source: str
    :param num_iterations: Number of iterations.
    :type num_iterations: int
    :param training_type: Training type. Possible values include: "TrainFull", "TrainAndValidate",
     "CrossValidate", "MeanCrossValidate".
    :type training_type: str or ~dfaz_management_client.models.TrainingType
    :param acquisition_function: Aquisition function. Possible values include: "EI", "PI", "UCB".
    :type acquisition_function: str or ~dfaz_management_client.models.AcquisitionFunction
    :param metrics: Optimization metrics.
    :type metrics: list[str or ~dfaz_management_client.models.OptimizationMetric]
    :param primary_metric: Primary optimization metric. Possible values include: "AUC_weighted",
     "Accuracy", "Norm_macro_recall", "Average_precision_score_weighted",
     "Precision_score_weighted", "Spearman_correlation", "Normalized_root_mean_squared_error",
     "R2_score", "Normalized_mean_absolute_error", "Normalized_root_mean_squared_log_error",
     "Mean_average_precision", "Iou".
    :type primary_metric: str or ~dfaz_management_client.models.OptimizationMetric
    :param train_split: Train split percentage.
    :type train_split: float
    :param acquisition_parameter: Aquisition parameter.
    :type acquisition_parameter: float
    :param num_cross_validation: Num cross validation.
    :type num_cross_validation: int
    :param target: Target.
    :type target: str
    :param aml_settings_json_string: AMLSettings Json string.
    :type aml_settings_json_string: str
    :param data_prep_json_string: Serialized DataPrep dataflow object.
    :type data_prep_json_string: str
    :param enable_subsampling: Enable subsampling.
    :type enable_subsampling: bool
    :param scenario: Which scenario is being used to mapping to a curated environment.
    :type scenario: str
    :param parent_run_id: The parent run id for the current parent run dto.
    :type parent_run_id: str
    :param test_type: Run type.
    :type test_type: str
    """

    _validation = {
        'job_type': {'required': True},
        'interaction_endpoints': {'readonly': True},
        'compute_binding': {'required': True},
        'code_configuration': {'required': True},
    }

    _attribute_map = {
        'job_type': {'key': 'jobType', 'type': 'str'},
        'interaction_endpoints': {'key': 'interactionEndpoints', 'type': 'JobBaseInteractionEndpoints'},
        'description': {'key': 'description', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'experiment_name': {'key': 'experimentName', 'type': 'str'},
        'compute_binding': {'key': 'computeBinding', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'max_run_duration_seconds': {'key': 'maxRunDurationSeconds', 'type': 'long'},
        'code_configuration': {'key': 'codeConfiguration', 'type': 'str'},
        'environment_id': {'key': 'environmentId', 'type': 'str'},
        'data_bindings': {'key': 'dataBindings', 'type': 'object'},
        'distribution_configuration': {'key': 'distributionConfiguration', 'type': 'object'},
        'run_type': {'key': 'runType', 'type': 'str'},
        'run_source': {'key': 'runSource', 'type': 'str'},
        'num_iterations': {'key': 'numIterations', 'type': 'int'},
        'training_type': {'key': 'trainingType', 'type': 'str'},
        'acquisition_function': {'key': 'acquisitionFunction', 'type': 'str'},
        'metrics': {'key': 'metrics', 'type': '[str]'},
        'primary_metric': {'key': 'primaryMetric', 'type': 'str'},
        'train_split': {'key': 'trainSplit', 'type': 'float'},
        'acquisition_parameter': {'key': 'acquisitionParameter', 'type': 'float'},
        'num_cross_validation': {'key': 'numCrossValidation', 'type': 'int'},
        'target': {'key': 'target', 'type': 'str'},
        'aml_settings_json_string': {'key': 'amlSettingsJsonString', 'type': 'str'},
        'data_prep_json_string': {'key': 'dataPrepJsonString', 'type': 'str'},
        'enable_subsampling': {'key': 'enableSubsampling', 'type': 'bool'},
        'scenario': {'key': 'scenario', 'type': 'str'},
        'parent_run_id': {'key': 'parentRunId', 'type': 'str'},
        'test_type': {'key': 'testType', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TestJob, self).__init__(**kwargs)
        self.job_type = 'TestJob'  # type: str
        self.test_type = kwargs.get('test_type', None)


class TriggerDependencyReference(DependencyReference):
    """Trigger referenced dependency.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: TumblingWindowTriggerDependencyReference.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. The type of dependency reference.Constant filled by server.
    :type type: str
    :param reference_trigger: Required. Referenced trigger.
    :type reference_trigger: ~dfaz_management_client.models.TriggerReference
    """

    _validation = {
        'type': {'required': True},
        'reference_trigger': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'reference_trigger': {'key': 'referenceTrigger', 'type': 'TriggerReference'},
    }

    _subtype_map = {
        'type': {'TumblingWindowTriggerDependencyReference': 'TumblingWindowTriggerDependencyReference'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TriggerDependencyReference, self).__init__(**kwargs)
        self.type = 'TriggerDependencyReference'  # type: str
        self.reference_trigger = kwargs['reference_trigger']


class TriggerFilterParameters(msrest.serialization.Model):
    """Query parameters for triggers.

    :param continuation_token: The continuation token for getting the next page of results. Null
     for first page.
    :type continuation_token: str
    :param parent_trigger_name: The name of the parent TumblingWindowTrigger to get the child rerun
     triggers.
    :type parent_trigger_name: str
    """

    _attribute_map = {
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
        'parent_trigger_name': {'key': 'parentTriggerName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TriggerFilterParameters, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.parent_trigger_name = kwargs.get('parent_trigger_name', None)


class TriggerListResponse(msrest.serialization.Model):
    """A list of trigger resources.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. List of triggers.
    :type value: list[~dfaz_management_client.models.TriggerResource]
    :param next_link: The link to the next page of results, if any remaining results exist.
    :type next_link: str
    """

    _validation = {
        'value': {'required': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[TriggerResource]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TriggerListResponse, self).__init__(**kwargs)
        self.value = kwargs['value']
        self.next_link = kwargs.get('next_link', None)


class TriggerPipelineReference(msrest.serialization.Model):
    """Pipeline that needs to be triggered with the given parameters.

    :param pipeline_reference: Pipeline reference.
    :type pipeline_reference: ~dfaz_management_client.models.PipelineReference
    :param parameters: Pipeline parameters.
    :type parameters: dict[str, object]
    """

    _attribute_map = {
        'pipeline_reference': {'key': 'pipelineReference', 'type': 'PipelineReference'},
        'parameters': {'key': 'parameters', 'type': '{object}'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TriggerPipelineReference, self).__init__(**kwargs)
        self.pipeline_reference = kwargs.get('pipeline_reference', None)
        self.parameters = kwargs.get('parameters', None)


class TriggerQueryResponse(msrest.serialization.Model):
    """A query of triggers.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. List of triggers.
    :type value: list[~dfaz_management_client.models.TriggerResource]
    :param continuation_token: The continuation token for getting the next page of results, if any
     remaining results exist, null otherwise.
    :type continuation_token: str
    """

    _validation = {
        'value': {'required': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[TriggerResource]'},
        'continuation_token': {'key': 'continuationToken', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TriggerQueryResponse, self).__init__(**kwargs)
        self.value = kwargs['value']
        self.continuation_token = kwargs.get('continuation_token', None)


class TriggerReference(msrest.serialization.Model):
    """Trigger reference type.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. Trigger reference type. Default value: "TriggerReference".
    :vartype type: str
    :param reference_name: Required. Reference trigger name.
    :type reference_name: str
    """

    _validation = {
        'type': {'required': True, 'constant': True},
        'reference_name': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'reference_name': {'key': 'referenceName', 'type': 'str'},
    }

    type = "TriggerReference"

    def __init__(
        self,
        **kwargs
    ):
        super(TriggerReference, self).__init__(**kwargs)
        self.reference_name = kwargs['reference_name']


class TriggerResource(SubResource):
    """Trigger resource type.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: The resource identifier.
    :vartype id: str
    :ivar name: The resource name.
    :vartype name: str
    :ivar type: The resource type.
    :vartype type: str
    :ivar etag: Etag identifies change in the resource.
    :vartype etag: str
    :param properties: Required. Properties of the trigger.
    :type properties: ~dfaz_management_client.models.Trigger
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'etag': {'readonly': True},
        'properties': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'etag': {'key': 'etag', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'Trigger'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TriggerResource, self).__init__(**kwargs)
        self.properties = kwargs['properties']


class TriggerSubscriptionOperationStatus(msrest.serialization.Model):
    """Defines the response of a trigger subscription operation.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar trigger_name: Trigger name.
    :vartype trigger_name: str
    :ivar status: Event Subscription Status. Possible values include: "Enabled", "Provisioning",
     "Deprovisioning", "Disabled", "Unknown".
    :vartype status: str or ~dfaz_management_client.models.EventSubscriptionStatus
    """

    _validation = {
        'trigger_name': {'readonly': True},
        'status': {'readonly': True},
    }

    _attribute_map = {
        'trigger_name': {'key': 'triggerName', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TriggerSubscriptionOperationStatus, self).__init__(**kwargs)
        self.trigger_name = None
        self.status = None


class TumblingWindowTrigger(Trigger):
    """Trigger that schedules pipeline runs for all fixed time interval windows from a start time without gaps and also supports backfill scenarios (when start time is in the past).

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, object]
    :param type: Required. Trigger type.Constant filled by server.
    :type type: str
    :param description: Trigger description.
    :type description: str
    :ivar runtime_state: Indicates if trigger is running or not. Updated when Start/Stop APIs are
     called on the Trigger. Possible values include: "Started", "Stopped", "Disabled".
    :vartype runtime_state: str or ~dfaz_management_client.models.TriggerRuntimeState
    :param annotations: List of tags that can be used for describing the trigger.
    :type annotations: list[object]
    :param pipeline: Required. Pipeline for which runs are created when an event is fired for
     trigger window that is ready.
    :type pipeline: ~dfaz_management_client.models.TriggerPipelineReference
    :param frequency: Required. The frequency of the time windows. Possible values include:
     "Minute", "Hour".
    :type frequency: str or ~dfaz_management_client.models.TumblingWindowFrequency
    :param interval: Required. The interval of the time windows. The minimum interval allowed is 15
     Minutes.
    :type interval: int
    :param start_time: Required. The start time for the time period for the trigger during which
     events are fired for windows that are ready. Only UTC time is currently supported.
    :type start_time: ~datetime.datetime
    :param end_time: The end time for the time period for the trigger during which events are fired
     for windows that are ready. Only UTC time is currently supported.
    :type end_time: ~datetime.datetime
    :param delay: Specifies how long the trigger waits past due time before triggering new run. It
     doesn't alter window start and end time. The default is 0. Type: string (or Expression with
     resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
    :type delay: object
    :param max_concurrency: Required. The max number of parallel time windows (ready for execution)
     for which a new run is triggered.
    :type max_concurrency: int
    :param retry_policy: Retry policy that will be applied for failed pipeline runs.
    :type retry_policy: ~dfaz_management_client.models.RetryPolicy
    :param depends_on: Triggers that this trigger depends on. Only tumbling window triggers are
     supported.
    :type depends_on: list[~dfaz_management_client.models.DependencyReference]
    """

    _validation = {
        'type': {'required': True},
        'runtime_state': {'readonly': True},
        'pipeline': {'required': True},
        'frequency': {'required': True},
        'interval': {'required': True},
        'start_time': {'required': True},
        'max_concurrency': {'required': True, 'maximum': 50, 'minimum': 1},
    }

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{object}'},
        'type': {'key': 'type', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'runtime_state': {'key': 'runtimeState', 'type': 'str'},
        'annotations': {'key': 'annotations', 'type': '[object]'},
        'pipeline': {'key': 'pipeline', 'type': 'TriggerPipelineReference'},
        'frequency': {'key': 'typeProperties.frequency', 'type': 'str'},
        'interval': {'key': 'typeProperties.interval', 'type': 'int'},
        'start_time': {'key': 'typeProperties.startTime', 'type': 'iso-8601'},
        'end_time': {'key': 'typeProperties.endTime', 'type': 'iso-8601'},
        'delay': {'key': 'typeProperties.delay', 'type': 'object'},
        'max_concurrency': {'key': 'typeProperties.maxConcurrency', 'type': 'int'},
        'retry_policy': {'key': 'typeProperties.retryPolicy', 'type': 'RetryPolicy'},
        'depends_on': {'key': 'typeProperties.dependsOn', 'type': '[DependencyReference]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TumblingWindowTrigger, self).__init__(**kwargs)
        self.type = 'TumblingWindowTrigger'  # type: str
        self.pipeline = kwargs['pipeline']
        self.frequency = kwargs['frequency']
        self.interval = kwargs['interval']
        self.start_time = kwargs['start_time']
        self.end_time = kwargs.get('end_time', None)
        self.delay = kwargs.get('delay', None)
        self.max_concurrency = kwargs['max_concurrency']
        self.retry_policy = kwargs.get('retry_policy', None)
        self.depends_on = kwargs.get('depends_on', None)


class TumblingWindowTriggerDependencyReference(TriggerDependencyReference):
    """Referenced tumbling window trigger dependency.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. The type of dependency reference.Constant filled by server.
    :type type: str
    :param reference_trigger: Required. Referenced trigger.
    :type reference_trigger: ~dfaz_management_client.models.TriggerReference
    :param offset: Timespan applied to the start time of a tumbling window when evaluating
     dependency.
    :type offset: str
    :param size: The size of the window when evaluating the dependency. If undefined the frequency
     of the tumbling window will be used.
    :type size: str
    """

    _validation = {
        'type': {'required': True},
        'reference_trigger': {'required': True},
        'offset': {'max_length': 15, 'min_length': 8, 'pattern': r'-?((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9]))'},
        'size': {'max_length': 15, 'min_length': 8, 'pattern': r'((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9]))'},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'reference_trigger': {'key': 'referenceTrigger', 'type': 'TriggerReference'},
        'offset': {'key': 'offset', 'type': 'str'},
        'size': {'key': 'size', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TumblingWindowTriggerDependencyReference, self).__init__(**kwargs)
        self.type = 'TumblingWindowTriggerDependencyReference'  # type: str
        self.offset = kwargs.get('offset', None)
        self.size = kwargs.get('size', None)


class UpdateIntegrationRuntimeRequest(msrest.serialization.Model):
    """Update integration runtime request.

    :param auto_update: Enables or disables the auto-update feature of the self-hosted integration
     runtime. See https://go.microsoft.com/fwlink/?linkid=854189. Possible values include: "On",
     "Off", "fakeValue1", "fakeValue2", "fakeValue3", "fakeValue4", "fakeValue5", "fakeValue6".
    :type auto_update: str or ~dfaz_management_client.models.IntegrationRuntimeAutoUpdate
    :param update_delay_offset: The time offset (in hours) in the day, e.g., PT03H is 3 hours. The
     integration runtime auto update will happen on that time.
    :type update_delay_offset: str
    """

    _attribute_map = {
        'auto_update': {'key': 'autoUpdate', 'type': 'str'},
        'update_delay_offset': {'key': 'updateDelayOffset', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(UpdateIntegrationRuntimeRequest, self).__init__(**kwargs)
        self.auto_update = kwargs.get('auto_update', None)
        self.update_delay_offset = kwargs.get('update_delay_offset', None)


class UserAccessPolicy(msrest.serialization.Model):
    """Get Data Plane read only token request definition.

    :param permissions: The string with permissions for Data Plane access. Currently only 'r' is
     supported which grants read only access.
    :type permissions: str
    :param access_resource_path: The resource path to get access relative to factory. Currently
     only empty string is supported which corresponds to the factory resource.
    :type access_resource_path: str
    :param profile_name: The name of the profile. Currently only the default is supported. The
     default value is DefaultProfile.
    :type profile_name: str
    :param start_time: Start time for the token. If not specified the current time will be used.
    :type start_time: str
    :param expire_time: Expiration time for the token. Maximum duration for the token is eight
     hours and by default the token will expire in eight hours.
    :type expire_time: str
    """

    _attribute_map = {
        'permissions': {'key': 'permissions', 'type': 'str'},
        'access_resource_path': {'key': 'accessResourcePath', 'type': 'str'},
        'profile_name': {'key': 'profileName', 'type': 'str'},
        'start_time': {'key': 'startTime', 'type': 'str'},
        'expire_time': {'key': 'expireTime', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(UserAccessPolicy, self).__init__(**kwargs)
        self.permissions = kwargs.get('permissions', None)
        self.access_resource_path = kwargs.get('access_resource_path', None)
        self.profile_name = kwargs.get('profile_name', None)
        self.start_time = kwargs.get('start_time', None)
        self.expire_time = kwargs.get('expire_time', None)
