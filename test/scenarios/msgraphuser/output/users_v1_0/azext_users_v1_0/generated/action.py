# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------


# pylint: disable=protected-access

# pylint: disable=no-self-use


import argparse
from collections import defaultdict
from knack.util import CLIError


class AddAssignedLicenses(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddAssignedLicenses, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'disabled_plans':
                d['disabled_plans'] = v[0]

            elif kl == 'sku_id':
                d['sku_id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter assigned-licenses. All possible keys are:'
                    ' disabled-plans, sku-id'.format(k)
                )

        return d


class AddAssignedPlans(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddAssignedPlans, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'assigned_date_time':
                d['assigned_date_time'] = v[0]

            elif kl == 'capability_status':
                d['capability_status'] = v[0]

            elif kl == 'service':
                d['service'] = v[0]

            elif kl == 'service_plan_id':
                d['service_plan_id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter assigned-plans. All possible keys are:'
                    ' assigned-date-time, capability-status, service, service-plan-id'.format(k)
                )

        return d


class AddIdentities(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddIdentities, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'issuer':
                d['issuer'] = v[0]

            elif kl == 'issuer_assigned_id':
                d['issuer_assigned_id'] = v[0]

            elif kl == 'sign_in_type':
                d['sign_in_type'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter identities. All possible keys are: issuer,'
                    ' issuer-assigned-id, sign-in-type'.format(k)
                )

        return d


class AddLicenseAssignmentStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddLicenseAssignmentStates, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'assigned_by_group':
                d['assigned_by_group'] = v[0]

            elif kl == 'disabled_plans':
                d['disabled_plans'] = v[0]

            elif kl == 'error':
                d['error'] = v[0]

            elif kl == 'sku_id':
                d['sku_id'] = v[0]

            elif kl == 'state':
                d['state'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter license-assignment-states. All possible keys are:'
                    ' assigned-by-group, disabled-plans, error, sku-id, state'.format(k)
                )

        return d


class AddOnPremisesExtensionAttributes(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)

        namespace.on_premises_extension_attributes = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'extension_attribute1':
                d['extension_attribute1'] = v[0]

            elif kl == 'extension_attribute10':
                d['extension_attribute10'] = v[0]

            elif kl == 'extension_attribute11':
                d['extension_attribute11'] = v[0]

            elif kl == 'extension_attribute12':
                d['extension_attribute12'] = v[0]

            elif kl == 'extension_attribute13':
                d['extension_attribute13'] = v[0]

            elif kl == 'extension_attribute14':
                d['extension_attribute14'] = v[0]

            elif kl == 'extension_attribute15':
                d['extension_attribute15'] = v[0]

            elif kl == 'extension_attribute2':
                d['extension_attribute2'] = v[0]

            elif kl == 'extension_attribute3':
                d['extension_attribute3'] = v[0]

            elif kl == 'extension_attribute4':
                d['extension_attribute4'] = v[0]

            elif kl == 'extension_attribute5':
                d['extension_attribute5'] = v[0]

            elif kl == 'extension_attribute6':
                d['extension_attribute6'] = v[0]

            elif kl == 'extension_attribute7':
                d['extension_attribute7'] = v[0]

            elif kl == 'extension_attribute8':
                d['extension_attribute8'] = v[0]

            elif kl == 'extension_attribute9':
                d['extension_attribute9'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter on-premises-extension-attributes. All possible keys'
                    ' are: extension-attribute1, extension-attribute10, extension-attribute11, extension-attribute12,'
                    ' extension-attribute13, extension-attribute14, extension-attribute15, extension-attribute2,'
                    ' extension-attribute3, extension-attribute4, extension-attribute5, extension-attribute6,'
                    ' extension-attribute7, extension-attribute8, extension-attribute9'.format(k)
                )

        return d


class AddOnPremisesProvisioningErrors(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddOnPremisesProvisioningErrors, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'category':
                d['category'] = v[0]

            elif kl == 'occurred_date_time':
                d['occurred_date_time'] = v[0]

            elif kl == 'property_causing_error':
                d['property_causing_error'] = v[0]

            elif kl == 'value':
                d['value'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter on-premises-provisioning-errors. All possible keys'
                    ' are: category, occurred-date-time, property-causing-error, value'.format(k)
                )

        return d


class AddPasswordProfile(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)

        namespace.password_profile = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'force_change_password_next_sign_in':
                d['force_change_password_next_sign_in'] = v[0]

            elif kl == 'force_change_password_next_sign_in_with_mfa':
                d['force_change_password_next_sign_in_with_mfa'] = v[0]

            elif kl == 'password':
                d['password'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter password-profile. All possible keys are:'
                    ' force-change-password-next-sign-in, force-change-password-next-sign-in-with-mfa, password'.format(
                        k
                    )
                )

        return d


class AddProvisionedPlans(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddProvisionedPlans, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'capability_status':
                d['capability_status'] = v[0]

            elif kl == 'provisioning_status':
                d['provisioning_status'] = v[0]

            elif kl == 'service':
                d['service'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter provisioned-plans. All possible keys are:'
                    ' capability-status, provisioning-status, service'.format(k)
                )

        return d


class AddAppRoleAssignments(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddAppRoleAssignments, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'app_role_id':
                d['app_role_id'] = v[0]

            elif kl == 'created_date_time':
                d['created_date_time'] = v[0]

            elif kl == 'principal_display_name':
                d['principal_display_name'] = v[0]

            elif kl == 'principal_id':
                d['principal_id'] = v[0]

            elif kl == 'principal_type':
                d['principal_type'] = v[0]

            elif kl == 'resource_display_name':
                d['resource_display_name'] = v[0]

            elif kl == 'resource_id':
                d['resource_id'] = v[0]

            elif kl == 'deleted_date_time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter app-role-assignments. All possible keys are:'
                    ' app-role-id, created-date-time, principal-display-name, principal-id, principal-type,'
                    ' resource-display-name, resource-id, deleted-date-time, id'.format(k)
                )

        return d


class AddCreatedObjects(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddCreatedObjects, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'deleted_date_time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter created-objects. All possible keys are:'
                    ' deleted-date-time, id'.format(k)
                )

        return d


class AddDirectReports(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddDirectReports, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'deleted_date_time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter direct-reports. All possible keys are:'
                    ' deleted-date-time, id'.format(k)
                )

        return d


class AddManager(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)

        namespace.manager = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'deleted_date_time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter manager. All possible keys are: deleted-date-time, id'
                    .format(k)
                )

        return d


class AddMemberOf(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddMemberOf, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'deleted_date_time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter member-of. All possible keys are:'
                    ' deleted-date-time, id'.format(k)
                )

        return d


class AddOauth2PermissionGrants(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddOauth2PermissionGrants, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'client_id':
                d['client_id'] = v[0]

            elif kl == 'consent_type':
                d['consent_type'] = v[0]

            elif kl == 'principal_id':
                d['principal_id'] = v[0]

            elif kl == 'resource_id':
                d['resource_id'] = v[0]

            elif kl == 'scope':
                d['scope'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter oauth2-permission-grants. All possible keys are:'
                    ' client-id, consent-type, principal-id, resource-id, scope, id'.format(k)
                )

        return d


class AddOwnedDevices(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddOwnedDevices, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'deleted_date_time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter owned-devices. All possible keys are:'
                    ' deleted-date-time, id'.format(k)
                )

        return d


class AddOwnedObjects(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddOwnedObjects, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'deleted_date_time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter owned-objects. All possible keys are:'
                    ' deleted-date-time, id'.format(k)
                )

        return d


class AddRegisteredDevices(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddRegisteredDevices, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'deleted_date_time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter registered-devices. All possible keys are:'
                    ' deleted-date-time, id'.format(k)
                )

        return d


class AddTransitiveMemberOf(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddTransitiveMemberOf, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'deleted_date_time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter transitive-member-of. All possible keys are:'
                    ' deleted-date-time, id'.format(k)
                )

        return d


class AddPhoto(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)

        namespace.photo = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'height':
                d['height'] = v[0]

            elif kl == 'width':
                d['width'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter photo. All possible keys are: height, width, id'
                    .format(k)
                )

        return d


class AddPhotos(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddPhotos, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'height':
                d['height'] = v[0]

            elif kl == 'width':
                d['width'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter photos. All possible keys are: height, width, id'
                    .format(k)
                )

        return d


class AddExtensions(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddExtensions, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter extensions. All possible keys are: id'.format(k)
                )

        return d


class AddDeviceManagementTroubleshootingEvents(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddDeviceManagementTroubleshootingEvents, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'correlation_id':
                d['correlation_id'] = v[0]

            elif kl == 'event_date_time':
                d['event_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter device-management-troubleshooting-events. All'
                    ' possible keys are: correlation-id, event-date-time, id'.format(k)
                )

        return d


class AddWithinSizeRange(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)

        namespace.within_size_range = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'maximum_size':
                d['maximum_size'] = v[0]

            elif kl == 'minimum_size':
                d['minimum_size'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter within-size-range. All possible keys are:'
                    ' maximum-size, minimum-size'.format(k)
                )

        return d


class AddResources(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddResources, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'content':
                d['content'] = v[0]

            elif kl == 'content_url':
                d['content_url'] = v[0]

            elif kl == 'gen_self':
                d['self_property'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter resources. All possible keys are: content,'
                    ' content-url, self, id'.format(k)
                )

        return d


class AddApplication(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)

        namespace.application = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'display_name':
                d['display_name'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter application. All possible keys are: display-name, id'
                    .format(k)
                )

        return d


class AddMasterCategories(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddMasterCategories, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'color':
                d['color'] = v[0]

            elif kl == 'display_name':
                d['display_name'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter master-categories. All possible keys are: color,'
                    ' display-name, id'.format(k)
                )

        return d


class AddLanguage(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)

        namespace.language = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'display_name':
                d['display_name'] = v[0]

            elif kl == 'locale':
                d['locale'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter language. All possible keys are: display-name, locale'
                    .format(k)
                )

        return d


class AddServicePlans(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        self.get_action(values, option_string)

        super(AddServicePlans, self).__call__(parser, namespace, item, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'applies_to':
                d['applies_to'] = v[0]

            elif kl == 'provisioning_status':
                d['provisioning_status'] = v[0]

            elif kl == 'service_plan_id':
                d['service_plan_id'] = v[0]

            elif kl == 'service_plan_name':
                d['service_plan_name'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter service-plans. All possible keys are: applies-to,'
                    ' provisioning-status, service-plan-id, service-plan-name'.format(k)
                )

        return d
